// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `content_from_json`, `encode`, `server_msg_to_json`

/// Public FRB helper: encode JSON representation of Content into protobuf bytes.
/// Caller must supply JSON generated by `proto_adapter` (including `raw`).
Future<Uint8List> encodeContent({required JsonValue content}) =>
    RustLib.instance.api.crateApiSocketApiEncodeContent(content: content);

/// Public FRB helper: decode protobuf bytes back into JSON (via `proto_adapter`).
/// This is the method Flutter clients should call to deserialize incoming payloads.
Future<JsonValue> decodeContent({required List<int> bytes}) =>
    RustLib.instance.api.crateApiSocketApiDecodeContent(bytes: bytes);

/// Pack a client payload JSON into a socket `ClientMsg`.
/// `ack`/`client_id` remain explicit fields, payload is translated to `msgpb::Content`.
Future<Uint8List> packClientMsg({
  required JsonValue payload,
  PlatformInt64? ack,
  PlatformInt64? clientId,
}) => RustLib.instance.api.crateApiSocketApiPackClientMsg(
  payload: payload,
  ack: ack,
  clientId: clientId,
);

/// Unpack raw socket bytes into JSON describing the upstream frame
/// (ID, timestamp, base64 payload).
Future<JsonValue> unpackServerMsg({required List<int> bytes}) =>
    RustLib.instance.api.crateApiSocketApiUnpackServerMsg(bytes: bytes);
