// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `content_from_json`, `encode`, `server_msg_to_json`

/// FRB 导出：把 Content 的 JSON 结构编码为 pb 字节；需传入 proto_adapter 生成的 JSON（包含 raw）。
Future<Uint8List> encodeContent({required JsonValue content}) =>
    RustLib.instance.api.crateApiSocketApiEncodeContent(content: content);

/// FRB 导出：解码 pb 字节为 JSON（经 proto_adapter），Flutter 收消息应调用此方法。
Future<JsonValue> decodeContent({required List<int> bytes}) =>
    RustLib.instance.api.crateApiSocketApiDecodeContent(bytes: bytes);

/// 打包客户端上行 JSON 为 socket ClientMsg，ack/client_id 保持显式字段，payload 转换为 msgpb::Content。
Future<Uint8List> packClientMsg({
  required JsonValue payload,
  PlatformInt64? ack,
  PlatformInt64? clientId,
}) => RustLib.instance.api.crateApiSocketApiPackClientMsg(
  payload: payload,
  ack: ack,
  clientId: clientId,
);

/// 解包下行原始字节为 JSON，含消息 ID/时间戳/base64 载荷。
Future<JsonValue> unpackServerMsg({required List<int> bytes}) =>
    RustLib.instance.api.crateApiSocketApiUnpackServerMsg(bytes: bytes);
