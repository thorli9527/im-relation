// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `ensure_app_api_base_url_initialized`, `ensure_attempts`, `ensure_limit_inner`, `get_app_api_base_url_internal`, `get_or_generate_value`, `get_or_init_attempts`, `get_or_set_u32`, `get_value`, `map_config_err`, `normalize_app_api_base_url`, `parse_value`, `set_numeric_value`, `set_value`

/// 获取设备 ID（若无则自动生成并保存）。
Future<String> getDeviceId() =>
    RustLib.instance.api.crateApiConfigApiGetDeviceId();

/// 获取应用版本号（用于展示）。
Future<String?> getAppVersion() =>
    RustLib.instance.api.crateApiConfigApiGetAppVersion();

/// 写入当前应用版本号。
Future<void> setAppVersion({required String version}) =>
    RustLib.instance.api.crateApiConfigApiSetAppVersion(version: version);

Future<String> getAppApiBaseUrl() =>
    RustLib.instance.api.crateApiConfigApiGetAppApiBaseUrl();

Future<void> setAppApiBaseUrl({required String baseUrl}) =>
    RustLib.instance.api.crateApiConfigApiSetAppApiBaseUrl(baseUrl: baseUrl);

Future<int?> getSocketReconnectLimit() =>
    RustLib.instance.api.crateApiConfigApiGetSocketReconnectLimit();

Future<void> setSocketReconnectLimit({required int limit}) =>
    RustLib.instance.api.crateApiConfigApiSetSocketReconnectLimit(limit: limit);

Future<int> ensureSocketReconnectLimit() =>
    RustLib.instance.api.crateApiConfigApiEnsureSocketReconnectLimit();

Future<int?> getSocketReconnectAttempts() =>
    RustLib.instance.api.crateApiConfigApiGetSocketReconnectAttempts();

Future<void> setSocketReconnectAttempts({required int attempts}) => RustLib
    .instance
    .api
    .crateApiConfigApiSetSocketReconnectAttempts(attempts: attempts);

Future<void> setSocketReconnectMessage({required String message}) => RustLib
    .instance
    .api
    .crateApiConfigApiSetSocketReconnectMessage(message: message);

Future<String?> getSocketReconnectMessage() =>
    RustLib.instance.api.crateApiConfigApiGetSocketReconnectMessage();

Future<String?> getToken() => RustLib.instance.api.crateApiConfigApiGetToken();

Future<void> setToken({required String token}) =>
    RustLib.instance.api.crateApiConfigApiSetToken(token: token);

Future<PlatformInt64?> getTokenExpireAt() =>
    RustLib.instance.api.crateApiConfigApiGetTokenExpireAt();

Future<void> setTokenExpireAt({required PlatformInt64 expireAt}) =>
    RustLib.instance.api.crateApiConfigApiSetTokenExpireAt(expireAt: expireAt);

Future<PlatformInt64?> getUid() =>
    RustLib.instance.api.crateApiConfigApiGetUid();

Future<void> setUid({required PlatformInt64 uid}) =>
    RustLib.instance.api.crateApiConfigApiSetUid(uid: uid);

Future<String?> getUsername() =>
    RustLib.instance.api.crateApiConfigApiGetUsername();

Future<void> setUsername({required String name}) =>
    RustLib.instance.api.crateApiConfigApiSetUsername(name: name);

Future<String?> getLoginName() =>
    RustLib.instance.api.crateApiConfigApiGetLoginName();

Future<void> setLoginName({required String name}) =>
    RustLib.instance.api.crateApiConfigApiSetLoginName(name: name);

Future<String?> getEmail() => RustLib.instance.api.crateApiConfigApiGetEmail();

Future<void> setEmail({required String email}) =>
    RustLib.instance.api.crateApiConfigApiSetEmail(email: email);

Future<String?> getPhone() => RustLib.instance.api.crateApiConfigApiGetPhone();

Future<void> setPhone({required String phone}) =>
    RustLib.instance.api.crateApiConfigApiSetPhone(phone: phone);

Future<String?> getAvatar() =>
    RustLib.instance.api.crateApiConfigApiGetAvatar();

Future<void> setAvatar({required String avatar}) =>
    RustLib.instance.api.crateApiConfigApiSetAvatar(avatar: avatar);

Future<PlatformInt64?> getLastLoginAt() =>
    RustLib.instance.api.crateApiConfigApiGetLastLoginAt();

Future<void> setLastLoginAt({required PlatformInt64 ts}) =>
    RustLib.instance.api.crateApiConfigApiSetLastLoginAt(ts: ts);

Future<PlatformInt64?> getLastAliveAt() =>
    RustLib.instance.api.crateApiConfigApiGetLastAliveAt();

Future<void> setLastAliveAt({required PlatformInt64 ts}) =>
    RustLib.instance.api.crateApiConfigApiSetLastAliveAt(ts: ts);
