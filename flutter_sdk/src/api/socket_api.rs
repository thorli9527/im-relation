use base64::engine::general_purpose::STANDARD;
use base64::Engine;
use bytes::BytesMut;
use flutter_rust_bridge::frb;
use prost::Message;
use serde_json::{json, Value as JsonValue};

use crate::{
    domain::proto_adapter::{content_to_json, json_to_content},
    generated::message as msgpb,
    generated::socket as socket_proto,
};

/// Encodes any `prost::Message` into `Vec<u8>` using a `BytesMut` buffer so we can reuse it.
fn encode<M: Message>(message: M) -> Result<Vec<u8>, String> {
    let mut buf = BytesMut::with_capacity(message.encoded_len());
    message
        .encode(&mut buf)
        .map_err(|err| format!("encode message: {err}"))?;
    Ok(buf.to_vec())
}

/// Restore `msgpb::Content` from JSON metadata that contains a `raw` base64 string.
/// The JSON format is produced by `proto_adapter::content_to_json`.
fn content_from_json(value: &JsonValue) -> Result<msgpb::Content, String> {
    json_to_content(value)
}

/// Serialize a `ServerMsg` into a lightweight JSON object for Dart.
fn server_msg_to_json(msg: socket_proto::ServerMsg) -> JsonValue {
    json!({
        "id": msg.id,
        "payload": STANDARD.encode(msg.payload),
        "ts_ms": msg.ts_ms,
    })
}

/// Public FRB helper: encode JSON representation of Content into protobuf bytes.
/// Caller must supply JSON generated by `proto_adapter` (including `raw`).
#[frb]
pub fn encode_content(content: JsonValue) -> Result<Vec<u8>, String> {
    let payload = content_from_json(&content)?;
    encode(payload)
}

/// Public FRB helper: decode protobuf bytes back into JSON (via `proto_adapter`).
/// This is the method Flutter clients should call to deserialize incoming payloads.
#[frb]
pub fn decode_content(bytes: Vec<u8>) -> Result<JsonValue, String> {
    let content = msgpb::Content::decode(bytes.as_slice()).map_err(|err| err.to_string())?;
    Ok(content_to_json(&content))
}

/// Pack a client payload JSON into a socket `ClientMsg`.
/// `ack`/`client_id` remain explicit fields, payload is translated to `msgpb::Content`.
#[frb]
pub fn pack_client_msg(
    payload: JsonValue,
    ack: Option<i64>,
    client_id: Option<i64>,
) -> Result<Vec<u8>, String> {
    let content = content_from_json(&payload)?;
    let pb = socket_proto::ClientMsg {
        ack,
        payload: encode(content)?,
        client_id,
    };
    encode(pb)
}

/// Unpack raw socket bytes into JSON describing the upstream frame
/// (ID, timestamp, base64 payload).
#[frb]
pub fn unpack_server_msg(bytes: Vec<u8>) -> Result<JsonValue, String> {
    let msg = socket_proto::ServerMsg::decode(bytes.as_slice()).map_err(|err| err.to_string())?;
    Ok(server_msg_to_json(msg))
}
