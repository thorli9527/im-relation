// This file is @generated by prost-build.
/// ======================================
/// ğŸ’  æ¶ˆæ¯å†…å®¹ç»“æ„ï¼ˆoneof ç±»å‹ï¼‰
/// ======================================
/// ä½¿ç”¨ oneof å®šä¹‰ä¸åŒç±»å‹çš„æ¶ˆæ¯å†…å®¹ï¼Œç¡®ä¿æ¶ˆæ¯ç±»å‹çš„äº’æ–¥æ€§
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageContent {
    #[prost(
        oneof = "message_content::Content",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 18, 24, 19, 20, 21, 22, 27"
    )]
    pub content: ::core::option::Option<message_content::Content>,
}
/// Nested message and enum types in `MessageContent`.
pub mod message_content {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Content {
        /// æ–‡æœ¬æ¶ˆæ¯ï¼šçº¯æ–‡æœ¬å†…å®¹
        #[prost(message, tag = "1")]
        Text(super::TextContent),
        /// å›¾ç‰‡æ¶ˆæ¯ï¼šå›¾ç‰‡æ–‡ä»¶
        #[prost(message, tag = "2")]
        Image(super::ImageContent),
        /// éŸ³é¢‘æ¶ˆæ¯ï¼šè¯­éŸ³æˆ–éŸ³ä¹
        #[prost(message, tag = "3")]
        Audio(super::AudioContent),
        /// è§†é¢‘æ¶ˆæ¯ï¼šè§†é¢‘æ–‡ä»¶
        #[prost(message, tag = "4")]
        Video(super::VideoContent),
        /// ä½ç½®æ¶ˆæ¯ï¼šåœ°ç†ä½ç½®ä¿¡æ¯
        #[prost(message, tag = "5")]
        Location(super::LocationContent),
        /// æ–‡ä»¶æ¶ˆæ¯ï¼šä»»æ„æ–‡ä»¶ç±»å‹
        #[prost(message, tag = "6")]
        File(super::FileContent),
        /// éŸ³è§†é¢‘é€šè¯ä¿¡ä»¤ï¼šé€šè¯æ§åˆ¶æ¶ˆæ¯
        #[prost(message, tag = "7")]
        AvCall(super::AvCallContent),
        /// è‡ªå®šä¹‰æ¶ˆæ¯ï¼šå¼€å‘è€…è‡ªå®šä¹‰ç»“æ„
        #[prost(message, tag = "8")]
        Custom(super::CustomContent),
        /// è¡¨æƒ…æ¶ˆæ¯ï¼šemoji è¡¨æƒ…
        #[prost(message, tag = "9")]
        Emoji(super::EmojiContent),
        /// æ’¤å›æ¶ˆæ¯ï¼šæ¶ˆæ¯æ’¤å›é€šçŸ¥
        #[prost(message, tag = "10")]
        Revoke(super::RevokeContent),
        /// è½¬å‘æ¶ˆæ¯ï¼šæ¶ˆæ¯è½¬å‘
        #[prost(message, tag = "11")]
        Forward(super::ForwardContent),
        /// å¼•ç”¨å›å¤æ¶ˆæ¯ï¼šå›å¤ç‰¹å®šæ¶ˆæ¯
        #[prost(message, tag = "12")]
        Quote(super::QuoteContent),
        /// HTML å¡ç‰‡ï¼šå¯Œæ–‡æœ¬å†…å®¹
        #[prost(message, tag = "13")]
        Html(super::HtmlContent),
        /// VOIP é€šè¯è®°å½•ï¼šé€šè¯æ—¥å¿—
        #[prost(message, tag = "14")]
        Voip(super::VoipContent),
        /// é€šçŸ¥æ¶ˆæ¯ï¼šç³»ç»Ÿé€šçŸ¥
        #[prost(message, tag = "15")]
        Notification(super::NotificationContent),
        /// æé†’æ¶ˆæ¯ï¼šæé†’äº‹é¡¹
        #[prost(message, tag = "17")]
        Reminder(super::ReminderContent),
        /// ç¾¤ç»„äº‹ä»¶ï¼šç¾¤ç»„ç›¸å…³äº‹ä»¶
        #[prost(message, tag = "18")]
        GroupEvent(super::GroupEventContent),
        /// å¥½å‹äº‹ä»¶ï¼šç”¨äºåŒæ­¥åˆ«å/å¤‡æ³¨å˜æ›´ç­‰
        #[prost(message, tag = "24")]
        FriendEvent(super::FriendEventContent),
        /// åç‰‡æ¶ˆæ¯ï¼šè”ç³»äººåˆ†äº«
        #[prost(message, tag = "19")]
        ContactCard(super::ContactCardContent),
        /// æŠ•ç¥¨æ¶ˆæ¯ï¼šæŠ•ç¥¨å†…å®¹
        #[prost(message, tag = "20")]
        Vote(super::VoteContent),
        /// çº¢åŒ…æ¶ˆæ¯ï¼šçº¢åŒ…å†…å®¹
        #[prost(message, tag = "21")]
        RedEnvelope(super::RedEnvelopeContent),
        /// åˆ é™¤æ¶ˆæ¯ï¼šç”¨äºé€šçŸ¥å„ç«¯æŸæ¡æ¶ˆæ¯å·²ç»è¢«åˆ é™¤ï¼ˆå¯é€‰å›æ»š/æ’¤å›ï¼‰
        #[prost(message, tag = "22")]
        Delete(super::DeleteContent),
        /// ä¸ªäººä¿¡æ¯æ›´æ–°ï¼šæ˜µç§°/å¤´åƒ/é‚®ç®±/ç”µè¯ç­‰åŒæ­¥
        #[prost(message, tag = "27")]
        ProfileUpdate(super::ProfileEventContent),
    }
}
/// ===============================
/// âœ… é€šç”¨ä¸šåŠ¡ç¡®è®¤/é€šçŸ¥ï¼ˆå¤„ç†ç»“æœå›æ‰§ï¼‰
/// ===============================
/// ç”¨äºæœåŠ¡ç«¯å‘å®¢æˆ·ç«¯å›ä¼ â€œè¯¥ä¸šåŠ¡å·²å¤„ç†â€çš„æ ‡å‡†ç»“æ„ã€‚
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AckContent {
    /// æ˜¯å¦æˆåŠŸ
    #[prost(bool, tag = "1")]
    pub ok: bool,
    /// ä¸šåŠ¡é”™è¯¯ç ï¼ˆ0 è¡¨ç¤ºæ— é”™è¯¯ï¼‰
    #[prost(int32, tag = "2")]
    pub code: i32,
    /// æ–‡æœ¬ä¿¡æ¯ï¼ˆå¯æœ¬åœ°åŒ–ï¼‰
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    /// å¯é€‰çš„å¼•ç”¨æ¶ˆæ¯ IDï¼ˆä¸æ­¤æ¬¡å¤„ç†ç›¸å…³çš„æ¶ˆæ¯ï¼‰
    #[prost(uint64, optional, tag = "5")]
    pub ref_message_id: ::core::option::Option<u64>,
    /// é™„åŠ æ•°æ®ï¼ˆé¢„ç•™ï¼‰
    #[prost(bytes = "vec", tag = "6")]
    pub extra: ::prost::alloc::vec::Vec<u8>,
}
/// ===============================
/// ğŸ—‘ï¸ åˆ é™¤æ¶ˆæ¯
/// ===============================
/// é€šçŸ¥å„ç«¯æŸæ¡æ¶ˆæ¯å·²ç»è¢«ç§»é™¤ï¼Œå¯ç”¨äºæ’¤å›æˆ–ç”¨æˆ·ä¸»åŠ¨åˆ é™¤
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteContent {
    /// è¢«åˆ é™¤çš„æ¶ˆæ¯ IDï¼ˆç”± sender ç”Ÿæˆï¼‰
    #[prost(uint64, tag = "1")]
    pub message_id: u64,
    /// å‘èµ·åˆ é™¤çš„ç”¨æˆ· ID
    #[prost(int64, tag = "2")]
    pub deleted_by: i64,
    /// åˆ é™¤äº‹ä»¶å‘ç”Ÿçš„æ—¶é—´
    #[prost(int64, tag = "3")]
    pub deleted_at: i64,
    /// æ˜¯å¦åŒæ­¥æ‰€æœ‰æˆå‘˜ï¼ˆtrue è¡¨ç¤ºâ€œæ’¤å›â€ï¼Œfalse ä»…åœ¨å½“å‰è®¾å¤‡éšè—ï¼‰
    #[prost(bool, tag = "4")]
    pub for_everyone: bool,
    /// å¯é€‰çš„åˆ é™¤åŸå› ï¼ˆä¾‹å¦‚â€œè¿è§„å†…å®¹â€ï¼‰
    #[prost(string, tag = "5")]
    pub reason: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ¤ å¥½å‹ä¸šåŠ¡æ¶ˆæ¯
/// ===============================
/// å°†ç”³è¯·ä¸å®¡æ ¸ç»„ç»‡åœ¨åŒä¸€ä¸ªä¸šåŠ¡è½½ä½“å†…ï¼Œä¾¿äº socket æ¨é€å’Œå‰ç«¯ç»Ÿä¸€æ¸²æŸ“
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FriendBusinessContent {
    #[prost(oneof = "friend_business_content::Action", tags = "1, 2")]
    pub action: ::core::option::Option<friend_business_content::Action>,
}
/// Nested message and enum types in `FriendBusinessContent`.
pub mod friend_business_content {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Action {
        #[prost(message, tag = "1")]
        Request(super::FriendRequestPayload),
        #[prost(message, tag = "2")]
        Decision(super::FriendRequestDecisionPayload),
    }
}
/// å¥½å‹ç”³è¯·ä¿¡æ¯
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FriendRequestPayload {
    #[prost(uint64, tag = "1")]
    pub request_id: u64,
    #[prost(int64, tag = "2")]
    pub from_user_id: i64,
    #[prost(int64, tag = "3")]
    pub to_user_id: i64,
    #[prost(string, tag = "4")]
    pub reason: ::prost::alloc::string::String,
    #[prost(enumeration = "FriendRequestSource", tag = "5")]
    pub source: i32,
    #[prost(int64, tag = "6")]
    pub created_at: i64,
    #[prost(string, tag = "7")]
    pub remark: ::prost::alloc::string::String,
    /// ç”³è¯·äººæƒ³å±•ç¤ºçš„åˆ«å/æ˜µç§°ï¼ˆå¯ç”¨äºé‚€è¯·å¡ç‰‡ï¼‰
    #[prost(string, tag = "8")]
    pub alias: ::prost::alloc::string::String,
}
/// å¥½å‹ç”³è¯·å¤„ç†ï¼ˆæ¥å—/æ‹’ç»ï¼‰ï¼ŒåŠ å…¥é»˜è®¤æ¶ˆæ¯å­—æ®µä»¥ä¾¿è‡ªåŠ¨ä¸‹å‘æ¬¢è¿/æç¤º
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FriendRequestDecisionPayload {
    #[prost(uint64, tag = "1")]
    pub request_id: u64,
    #[prost(bool, tag = "2")]
    pub accepted: bool,
    #[prost(string, tag = "3")]
    pub remark: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub decided_at: i64,
    #[prost(bool, tag = "5")]
    pub send_default_message: bool,
    #[prost(string, tag = "6")]
    pub default_message: ::prost::alloc::string::String,
    /// å®¡æ‰¹äººå¸Œæœ›å±•ç¤ºç»™ç”³è¯·äººçš„åˆ«å/ç§°å‘¼
    #[prost(string, tag = "7")]
    pub alias: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FriendEventContent {
    /// è§¦å‘äº‹ä»¶çš„ç”¨æˆ·ï¼ˆé€šå¸¸æ˜¯ operator/å‘èµ·è€…ï¼‰
    #[prost(int64, tag = "1")]
    pub operator_id: i64,
    /// å…³è”çš„å¥½å‹ IDï¼ˆäº‹ä»¶å¯¹è±¡ï¼‰
    #[prost(int64, tag = "2")]
    pub friend_id: i64,
    /// äº‹ä»¶ç±»å‹
    #[prost(enumeration = "FriendEventType", tag = "3")]
    pub r#type: i32,
    /// æ–°åˆ«åï¼ˆå¯é€‰ï¼‰
    #[prost(string, optional, tag = "4")]
    pub alias: ::core::option::Option<::prost::alloc::string::String>,
    /// æ–°å¤‡æ³¨ï¼ˆå¯é€‰ï¼‰
    #[prost(string, optional, tag = "5")]
    pub remark: ::core::option::Option<::prost::alloc::string::String>,
    /// äº‹ä»¶å‘ç”Ÿæ—¶é—´
    #[prost(int64, tag = "6")]
    pub at: i64,
    /// äº‹ä»¶åŸå› ï¼ˆä¾‹å¦‚â€œå®¢æˆ·ç«¯ä¿®æ”¹â€/â€œå®¡æ‰¹â€ï¼‰
    #[prost(string, tag = "7")]
    pub reason: ::prost::alloc::string::String,
    /// å¯æ‰©å±• metadata
    #[prost(map = "string, string", tag = "8")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// ===============================
/// ğŸ‘¥ ç¾¤ä¸šåŠ¡æ¶ˆæ¯
/// ===============================
/// å°†åŠ ç¾¤ç”³è¯·ä¸å®¡æ ¸å°è£…åœ¨åŒä¸€ä¸šåŠ¡è½½ä½“
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupBusinessContent {
    #[prost(oneof = "group_business_content::Action", tags = "1, 2, 3")]
    pub action: ::core::option::Option<group_business_content::Action>,
}
/// Nested message and enum types in `GroupBusinessContent`.
pub mod group_business_content {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Action {
        #[prost(message, tag = "1")]
        JoinRequest(super::GroupJoinRequestPayload),
        #[prost(message, tag = "2")]
        JoinDecision(super::GroupJoinDecisionPayload),
        #[prost(message, tag = "3")]
        Create(super::GroupCreateContent),
    }
}
/// åŠ ç¾¤ç”³è¯·
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GroupJoinRequestPayload {
    #[prost(uint64, tag = "1")]
    pub request_id: u64,
    #[prost(int64, tag = "2")]
    pub group_id: i64,
    #[prost(int64, tag = "3")]
    pub applicant_id: i64,
    #[prost(string, tag = "4")]
    pub reason: ::prost::alloc::string::String,
    #[prost(int64, tag = "5")]
    pub created_at: i64,
    #[prost(int64, repeated, tag = "6")]
    pub via_member_ids: ::prost::alloc::vec::Vec<i64>,
}
/// åŠ ç¾¤ç”³è¯·å®¡æ‰¹
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GroupJoinDecisionPayload {
    #[prost(uint64, tag = "1")]
    pub request_id: u64,
    #[prost(int64, tag = "2")]
    pub group_id: i64,
    #[prost(bool, tag = "3")]
    pub approved: bool,
    #[prost(int64, tag = "4")]
    pub decided_at: i64,
    #[prost(string, tag = "5")]
    pub remark: ::prost::alloc::string::String,
    #[prost(int64, repeated, tag = "6")]
    pub approved_member_ids: ::prost::alloc::vec::Vec<i64>,
    #[prost(bool, tag = "7")]
    pub send_default_message: bool,
    #[prost(string, tag = "8")]
    pub default_message: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ—ï¸ ç¾¤åˆ›å»º/åˆå§‹åŒ–
/// ===============================
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GroupCreationMember {
    #[prost(int64, tag = "1")]
    pub member_id: i64,
    #[prost(string, optional, tag = "2")]
    pub alias: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3")]
    pub role: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupCreateContent {
    #[prost(string, tag = "1")]
    pub group_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub members: ::prost::alloc::vec::Vec<GroupCreationMember>,
    #[prost(string, tag = "3")]
    pub notice: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub event: ::core::option::Option<GroupEventContent>,
}
/// ===============================
/// ğŸ“„ æ–‡æœ¬æ¶ˆæ¯
/// ===============================
/// æ”¯æŒçº¯æ–‡æœ¬å’Œå¯Œæ–‡æœ¬æ ¼å¼ï¼ŒåŒ…å«å†…è”å®ä½“ï¼ˆé“¾æ¥ã€@ç”¨æˆ·ã€è¯é¢˜ç­‰ï¼‰
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextContent {
    /// æ–‡æœ¬ä¸»ä½“å†…å®¹ï¼šæ¶ˆæ¯çš„æ–‡æœ¬å†…å®¹
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    /// å¯Œæ–‡æœ¬å®ä½“ï¼Œå¦‚é“¾æ¥/@ç”¨æˆ·/è¯é¢˜ï¼šæ–‡æœ¬ä¸­çš„ç‰¹æ®Šå…ƒç´ 
    #[prost(message, repeated, tag = "2")]
    pub entities: ::prost::alloc::vec::Vec<InlineEntity>,
}
/// å†…è”å®ä½“ï¼šç”¨äºåœ¨æ–‡æœ¬ä¸­æ ‡è®°ç‰¹æ®Šå…ƒç´ 
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InlineEntity {
    /// èµ·å§‹ä½ç½®ï¼ˆUTF-8 å­—ç¬¦ç´¢å¼•ï¼‰ï¼šå®ä½“åœ¨æ–‡æœ¬ä¸­çš„å¼€å§‹ä½ç½®
    #[prost(int32, tag = "1")]
    pub start: i32,
    /// ç»“æŸä½ç½®ï¼ˆä¸å«ï¼‰ï¼šå®ä½“åœ¨æ–‡æœ¬ä¸­çš„ç»“æŸä½ç½®
    #[prost(int32, tag = "2")]
    pub end: i32,
    /// ç±»å‹ï¼šlink / mention / hashtagï¼šå®ä½“çš„ç±»å‹
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
    /// é™„åŠ å€¼ï¼šURLã€ç”¨æˆ·IDç­‰ï¼šå®ä½“çš„å…·ä½“å€¼
    #[prost(string, tag = "4")]
    pub value: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ–¼ï¸ å›¾ç‰‡æ¶ˆæ¯
/// ===============================
/// åŒ…å«å›¾ç‰‡çš„å®Œæ•´ä¿¡æ¯ï¼Œæ”¯æŒåŸå›¾å’Œç¼©ç•¥å›¾
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ImageContent {
    /// åŸå›¾ URLï¼šå›¾ç‰‡çš„å®Œæ•´åœ°å€
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    /// ç¼©ç•¥å›¾ URLï¼šå›¾ç‰‡çš„ç¼©ç•¥å›¾åœ°å€
    #[prost(string, tag = "2")]
    pub thumbnail_url: ::prost::alloc::string::String,
    /// å®½åº¦ï¼ˆåƒç´ ï¼‰ï¼šå›¾ç‰‡çš„å®½åº¦
    #[prost(int32, tag = "3")]
    pub width: i32,
    /// é«˜åº¦ï¼ˆåƒç´ ï¼‰ï¼šå›¾ç‰‡çš„é«˜åº¦
    #[prost(int32, tag = "4")]
    pub height: i32,
    /// æ ¼å¼ï¼ˆå¦‚ jpg/pngï¼‰ï¼šå›¾ç‰‡çš„æ–‡ä»¶æ ¼å¼
    #[prost(string, tag = "5")]
    pub format: ::prost::alloc::string::String,
    /// æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰ï¼šå›¾ç‰‡æ–‡ä»¶çš„å¤§å°
    #[prost(int64, tag = "6")]
    pub size: i64,
}
/// ===============================
/// ğŸ”Š éŸ³é¢‘æ¶ˆæ¯
/// ===============================
/// æ”¯æŒè¯­éŸ³èŠå¤©å’ŒéŸ³ä¹æ’­æ”¾ï¼ŒåŒ…å«æ—¶é•¿å’Œæ ¼å¼ä¿¡æ¯
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AudioContent {
    /// éŸ³é¢‘æ–‡ä»¶ URLï¼šéŸ³é¢‘æ–‡ä»¶çš„åœ°å€
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    /// æ—¶é•¿ï¼ˆç§’ï¼‰ï¼šéŸ³é¢‘çš„æ’­æ”¾æ—¶é•¿
    #[prost(int32, tag = "2")]
    pub duration: i32,
    /// æ ¼å¼ï¼šéŸ³é¢‘æ–‡ä»¶æ ¼å¼ï¼ˆå¦‚ mp3/wavï¼‰
    #[prost(string, tag = "3")]
    pub format: ::prost::alloc::string::String,
    /// æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰ï¼šéŸ³é¢‘æ–‡ä»¶çš„å¤§å°
    #[prost(int64, tag = "4")]
    pub size: i64,
    /// æ˜¯å¦è¯­éŸ³ï¼ˆvs éŸ³ä¹ç±»éŸ³é¢‘ï¼‰ï¼štrueè¡¨ç¤ºè¯­éŸ³ï¼Œfalseè¡¨ç¤ºéŸ³ä¹
    #[prost(bool, tag = "5")]
    pub is_voice: bool,
}
/// ===============================
/// ğŸï¸ è§†é¢‘æ¶ˆæ¯
/// ===============================
/// åŒ…å«è§†é¢‘æ–‡ä»¶å’Œå°é¢å›¾ï¼Œæ”¯æŒæ’­æ”¾æ§åˆ¶
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VideoContent {
    /// è§†é¢‘æ–‡ä»¶ URLï¼šè§†é¢‘æ–‡ä»¶çš„åœ°å€
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    /// æ—¶é•¿ï¼ˆç§’ï¼‰ï¼šè§†é¢‘çš„æ’­æ”¾æ—¶é•¿
    #[prost(int32, tag = "2")]
    pub duration: i32,
    /// å°é¢å›¾ URLï¼šè§†é¢‘çš„å°é¢å›¾ç‰‡
    #[prost(string, tag = "3")]
    pub cover_url: ::prost::alloc::string::String,
    /// å®½åº¦ï¼ˆåƒç´ ï¼‰ï¼šè§†é¢‘çš„å®½åº¦
    #[prost(int32, tag = "4")]
    pub width: i32,
    /// é«˜åº¦ï¼ˆåƒç´ ï¼‰ï¼šè§†é¢‘çš„é«˜åº¦
    #[prost(int32, tag = "5")]
    pub height: i32,
    /// æ ¼å¼ï¼šè§†é¢‘æ–‡ä»¶æ ¼å¼ï¼ˆå¦‚ mp4/aviï¼‰
    #[prost(string, tag = "6")]
    pub format: ::prost::alloc::string::String,
    /// æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰ï¼šè§†é¢‘æ–‡ä»¶çš„å¤§å°
    #[prost(int64, tag = "7")]
    pub size: i64,
}
/// ===============================
/// ğŸ“ ä½ç½®æ¶ˆæ¯
/// ===============================
/// åŒ…å«åœ°ç†ä½ç½®ä¿¡æ¯ï¼Œæ”¯æŒåœ°å€æè¿°å’Œåœ°å›¾æ˜¾ç¤º
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocationContent {
    /// çº¬åº¦ï¼šåœ°ç†ä½ç½®çš„çº¬åº¦åæ ‡
    #[prost(double, tag = "1")]
    pub latitude: f64,
    /// ç»åº¦ï¼šåœ°ç†ä½ç½®çš„ç»åº¦åæ ‡
    #[prost(double, tag = "2")]
    pub longitude: f64,
    /// åœ°å€æè¿°ï¼šä½ç½®çš„æ–‡å­—æè¿°
    #[prost(string, tag = "3")]
    pub address: ::prost::alloc::string::String,
    /// åœ°ç‚¹åç§°ï¼šå…·ä½“çš„åœ°ç‚¹åç§°
    #[prost(string, tag = "4")]
    pub poi_name: ::prost::alloc::string::String,
    /// ç¼©ç•¥å›¾ URLï¼šä½ç½®çš„åœ°å›¾ç¼©ç•¥å›¾
    #[prost(string, tag = "5")]
    pub thumbnail_url: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ“ æ–‡ä»¶æ¶ˆæ¯
/// ===============================
/// æ”¯æŒä»»æ„æ–‡ä»¶ç±»å‹ï¼ŒåŒ…å«æ–‡ä»¶ä¿¡æ¯å’Œå›¾æ ‡
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FileContent {
    /// æ–‡ä»¶ URLï¼šæ–‡ä»¶çš„ä¸‹è½½åœ°å€
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    /// æ–‡ä»¶åï¼šæ–‡ä»¶çš„æ˜¾ç¤ºåç§°
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰ï¼šæ–‡ä»¶çš„å¤§å°
    #[prost(int64, tag = "3")]
    pub size: i64,
    /// æ–‡ä»¶ç±»å‹ï¼šæ–‡ä»¶çš„ MIME ç±»å‹
    #[prost(string, tag = "4")]
    pub file_type: ::prost::alloc::string::String,
    /// å›¾æ ‡ URLï¼šæ–‡ä»¶ç±»å‹çš„å›¾æ ‡
    #[prost(string, tag = "5")]
    pub icon_url: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ“ éŸ³è§†é¢‘é€šè¯ä¿¡ä»¤
/// ===============================
/// ç”¨äºéŸ³è§†é¢‘é€šè¯çš„æ§åˆ¶ä¿¡ä»¤ï¼ŒåŒ…å«é€šè¯çŠ¶æ€å’Œå‚ä¸è€…ä¿¡æ¯
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AvCallContent {
    /// é€šè¯ IDï¼šé€šè¯çš„å”¯ä¸€æ ‡è¯†
    #[prost(string, tag = "1")]
    pub call_id: ::prost::alloc::string::String,
    /// å‘èµ·è€… IDï¼šé€šè¯çš„å‘èµ·ç”¨æˆ·
    #[prost(int64, tag = "2")]
    pub initiator_uid: i64,
    /// å‚ä¸è€… ID åˆ—è¡¨ï¼šé€šè¯çš„æ‰€æœ‰å‚ä¸è€…
    #[prost(int64, repeated, tag = "3")]
    pub participant_ids: ::prost::alloc::vec::Vec<i64>,
    /// é€šè¯æ“ä½œï¼šå…·ä½“çš„é€šè¯åŠ¨ä½œ
    #[prost(enumeration = "av_call_content::CallAction", tag = "4")]
    pub action: i32,
    /// é€šè¯ç±»å‹ï¼šé€šè¯çš„ç±»å‹
    #[prost(enumeration = "av_call_content::CallType", tag = "5")]
    pub r#type: i32,
    /// æ—¶é—´æˆ³ï¼šæ“ä½œçš„æ—¶é—´
    #[prost(int64, tag = "6")]
    pub timestamp: i64,
    /// æ—¶é•¿ï¼ˆç§’ï¼‰ï¼šé€šè¯çš„æŒç»­æ—¶é—´
    #[prost(int32, tag = "7")]
    pub duration: i32,
}
/// Nested message and enum types in `AVCallContent`.
pub mod av_call_content {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CallAction {
        /// æœªçŸ¥æ“ä½œ
        Unknown = 0,
        /// é‚€è¯·ï¼šå‘èµ·é€šè¯é‚€è¯·
        Invite = 1,
        /// æ¥å—ï¼šæ¥å—é€šè¯é‚€è¯·
        Accept = 2,
        /// æ‹’ç»ï¼šæ‹’ç»é€šè¯é‚€è¯·
        Reject = 3,
        /// å–æ¶ˆï¼šå–æ¶ˆé€šè¯
        Cancel = 4,
        /// ç»“æŸï¼šç»“æŸé€šè¯
        End = 5,
        /// è¶…æ—¶ï¼šé€šè¯è¶…æ—¶
        Timeout = 6,
    }
    impl CallAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Invite => "INVITE",
                Self::Accept => "ACCEPT",
                Self::Reject => "REJECT",
                Self::Cancel => "CANCEL",
                Self::End => "END",
                Self::Timeout => "TIMEOUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "INVITE" => Some(Self::Invite),
                "ACCEPT" => Some(Self::Accept),
                "REJECT" => Some(Self::Reject),
                "CANCEL" => Some(Self::Cancel),
                "END" => Some(Self::End),
                "TIMEOUT" => Some(Self::Timeout),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CallType {
        /// éŸ³é¢‘é€šè¯ï¼šä»…è¯­éŸ³é€šè¯
        Audio = 0,
        /// è§†é¢‘é€šè¯ï¼šéŸ³è§†é¢‘é€šè¯
        Video = 1,
    }
    impl CallType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Audio => "AUDIO",
                Self::Video => "VIDEO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AUDIO" => Some(Self::Audio),
                "VIDEO" => Some(Self::Video),
                _ => None,
            }
        }
    }
}
/// ===============================
/// ğŸ’  è‡ªå®šä¹‰ç»“æ„åŒ–æ¶ˆæ¯
/// ===============================
/// æ”¯æŒå¼€å‘è€…è‡ªå®šä¹‰çš„æ¶ˆæ¯ç»“æ„ï¼Œé€šå¸¸ä»¥ JSON æ ¼å¼æ‰¿è½½
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CustomContent {
    /// è‡ªå®šä¹‰ç±»å‹ï¼šæ¶ˆæ¯çš„è‡ªå®šä¹‰ç±»å‹æ ‡è¯†
    #[prost(string, tag = "1")]
    pub custom_type: ::prost::alloc::string::String,
    /// JSON è½½è·ï¼šè‡ªå®šä¹‰æ¶ˆæ¯çš„ JSON æ•°æ®
    #[prost(string, tag = "2")]
    pub json_payload: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ˜„ è¡¨æƒ…æ¶ˆæ¯
/// ===============================
/// æ”¯æŒæ ‡å‡† emoji å’Œè‡ªå®šä¹‰è¡¨æƒ…
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EmojiContent {
    /// è¡¨æƒ…ç±»å‹ï¼šæ ‡å‡† emoji ç±»å‹
    #[prost(enumeration = "EmojiType", tag = "1")]
    pub emoji: i32,
    /// è‡ªå®šä¹‰è¡¨æƒ… URLï¼šè‡ªå®šä¹‰è¡¨æƒ…çš„å›¾ç‰‡åœ°å€
    #[prost(string, tag = "2")]
    pub custom_emoji_url: ::prost::alloc::string::String,
}
/// ===============================
/// â›” æ’¤å›æ¶ˆæ¯
/// ===============================
/// ç”¨äºé€šçŸ¥æ¶ˆæ¯æ’¤å›ï¼ŒåŒ…å«æ’¤å›çš„ç›®æ ‡æ¶ˆæ¯ä¿¡æ¯
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RevokeContent {
    /// ç›®æ ‡æ¶ˆæ¯ IDï¼šè¢«æ’¤å›çš„æ¶ˆæ¯ID
    #[prost(int64, tag = "1")]
    pub target_message_id: i64,
    /// æ“ä½œè€… IDï¼šæ‰§è¡Œæ’¤å›æ“ä½œçš„ç”¨æˆ·
    #[prost(int64, tag = "2")]
    pub operator_id: i64,
    /// æ’¤å›æ—¶é—´ï¼šæ’¤å›æ“ä½œçš„æ—¶é—´æˆ³
    #[prost(int64, tag = "3")]
    pub revoke_time: i64,
}
/// ===============================
/// ğŸ“¤ è½¬å‘æ¶ˆæ¯
/// ===============================
/// ç”¨äºæ¶ˆæ¯è½¬å‘ï¼ŒåŒ…å«åŸæ¶ˆæ¯çš„åŸºæœ¬ä¿¡æ¯
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ForwardContent {
    /// åŸæ¶ˆæ¯ IDï¼šè¢«è½¬å‘æ¶ˆæ¯çš„ID
    #[prost(uint64, tag = "1")]
    pub original_message_id: u64,
    /// åŸå‘é€è€… IDï¼šåŸæ¶ˆæ¯çš„å‘é€è€…
    #[prost(string, tag = "2")]
    pub original_sender_id: ::prost::alloc::string::String,
    /// æ‘˜è¦ï¼šè½¬å‘çš„æ‘˜è¦ä¿¡æ¯
    #[prost(string, tag = "4")]
    pub summary: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ“Œ å¼•ç”¨å›å¤æ¶ˆæ¯
/// ===============================
/// ç”¨äºå›å¤ç‰¹å®šæ¶ˆæ¯ï¼ŒåŒ…å«è¢«å¼•ç”¨æ¶ˆæ¯çš„ä¿¡æ¯
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QuoteContent {
    /// è¢«å¼•ç”¨æ¶ˆæ¯ IDï¼šè¢«å›å¤æ¶ˆæ¯çš„ID
    #[prost(uint64, tag = "1")]
    pub quoted_message_id: u64,
    /// è¢«å¼•ç”¨å†…å®¹é¢„è§ˆï¼šè¢«å›å¤æ¶ˆæ¯çš„é¢„è§ˆ
    #[prost(string, tag = "2")]
    pub quoted_content_preview: ::prost::alloc::string::String,
    /// å¼•ç”¨æ–‡æœ¬ï¼šå›å¤çš„æ–‡æœ¬å†…å®¹
    #[prost(string, tag = "3")]
    pub quote_text: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸŒ HTML å¡ç‰‡
/// ===============================
/// ç”¨äºå¯Œæ–‡æœ¬å†…å®¹ï¼Œæ”¯æŒç½‘é¡µé“¾æ¥å’Œé¢„è§ˆ
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HtmlContent {
    /// æ ‡é¢˜ï¼šå¡ç‰‡çš„æ ‡é¢˜
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    /// URLï¼šé“¾æ¥åœ°å€
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    /// é¢„è§ˆï¼šå†…å®¹çš„é¢„è§ˆæ–‡æœ¬
    #[prost(string, tag = "3")]
    pub preview: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ“ VOIP é€šè¯è®°å½•
/// ===============================
/// ç”¨äºè®°å½•é€šè¯å†å²ï¼ŒåŒ…å«é€šè¯çš„åŸºæœ¬ä¿¡æ¯
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VoipContent {
    /// ä¸»å« IDï¼šå‘èµ·é€šè¯çš„ç”¨æˆ·
    #[prost(string, tag = "1")]
    pub caller_id: ::prost::alloc::string::String,
    /// è¢«å« IDï¼šæ¥æ”¶é€šè¯çš„ç”¨æˆ·
    #[prost(string, tag = "2")]
    pub callee_id: ::prost::alloc::string::String,
    /// é€šè¯æ—¶é•¿ï¼ˆç§’ï¼‰ï¼šé€šè¯çš„æŒç»­æ—¶é—´
    #[prost(int64, tag = "3")]
    pub duration: i64,
    /// é€šè¯çŠ¶æ€ï¼šé€šè¯çš„ç»“æœçŠ¶æ€
    #[prost(string, tag = "4")]
    pub status: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ”” é€šçŸ¥æ¶ˆæ¯
/// ===============================
/// ç”¨äºç³»ç»Ÿé€šçŸ¥ï¼ŒåŒ…å«æ ‡é¢˜ã€å†…å®¹å’Œå…ƒæ•°æ®
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotificationContent {
    /// æ ‡é¢˜ï¼šé€šçŸ¥çš„æ ‡é¢˜
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    /// å†…å®¹ï¼šé€šçŸ¥çš„ä¸»ä½“å†…å®¹
    #[prost(string, tag = "2")]
    pub body: ::prost::alloc::string::String,
    /// å…ƒæ•°æ®ï¼šé€šçŸ¥çš„é™„åŠ ä¿¡æ¯
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemBusinessContent {
    /// ç±»å‹ï¼šå…è®¸é¢„å®šä¹‰æšä¸¾ä»¥ä¾¿å®¢æˆ·ç«¯/æœåŠ¡ç«¯ç»Ÿä¸€å¤„ç†
    #[prost(enumeration = "SystemBusinessType", tag = "1")]
    pub business_type: i32,
    /// æ ‡é¢˜
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    /// è¯¦ç»†å†…å®¹ï¼ˆå¯ç”¨ JSON ç­‰ç»“æ„ï¼‰
    #[prost(string, tag = "3")]
    pub detail: ::prost::alloc::string::String,
    /// é™„åŠ ä¸Šä¸‹æ–‡ï¼Œå¦‚å…³è” IDã€å‘èµ·æ–¹ç­‰
    #[prost(map = "string, string", tag = "4")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// çŸ­æ‘˜è¦ï¼ˆå¯ç”¨äºåˆ—è¡¨ï¼‰
    #[prost(string, optional, tag = "5")]
    pub summary: ::core::option::Option<::prost::alloc::string::String>,
    /// å…·ä½“æ­£æ–‡å†…å®¹æˆ–è·³è½¬æ–‡æ¡ˆ
    #[prost(string, optional, tag = "6")]
    pub body: ::core::option::Option<::prost::alloc::string::String>,
    /// å±•ç¤ºåŒºåŸŸï¼ˆä¾‹å¦‚é¦–é¡µ/å¼¹çª—/ bannerï¼‰
    #[prost(enumeration = "system_business_content::DisplayArea", tag = "7")]
    pub display_area: i32,
    /// å…³è”è·³è½¬åœ°å€
    #[prost(string, optional, tag = "8")]
    pub action_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "9")]
    pub valid_from: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "10")]
    pub valid_to: ::core::option::Option<i64>,
}
/// Nested message and enum types in `SystemBusinessContent`.
pub mod system_business_content {
    /// æ˜¾ç¤ºåŒºåŸŸï¼šç”¨äºæ§åˆ¶å®¢æˆ·ç«¯åœ¨å“ªäº›ä½ç½®å±•ç¤º
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DisplayArea {
        DisplayUnknown = 0,
        DisplayHome = 1,
        DisplayPopup = 2,
        DisplayBanner = 3,
    }
    impl DisplayArea {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::DisplayUnknown => "DISPLAY_UNKNOWN",
                Self::DisplayHome => "DISPLAY_HOME",
                Self::DisplayPopup => "DISPLAY_POPUP",
                Self::DisplayBanner => "DISPLAY_BANNER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DISPLAY_UNKNOWN" => Some(Self::DisplayUnknown),
                "DISPLAY_HOME" => Some(Self::DisplayHome),
                "DISPLAY_POPUP" => Some(Self::DisplayPopup),
                "DISPLAY_BANNER" => Some(Self::DisplayBanner),
                _ => None,
            }
        }
    }
}
/// ===============================
/// â° æé†’äº‹é¡¹
/// ===============================
/// ç”¨äºæé†’åŠŸèƒ½ï¼ŒåŒ…å«æé†’æ–‡æœ¬å’Œæ—¶é—´
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReminderContent {
    /// æ–‡æœ¬ï¼šæé†’çš„å†…å®¹
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    /// æé†’æ—¶é—´ï¼šæé†’è§¦å‘çš„æ—¶é—´æˆ³
    #[prost(int64, tag = "2")]
    pub remind_at: i64,
}
/// ä¸ªäººèµ„æ–™äº‹ä»¶è½½ä½“
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProfileEventContent {
    #[prost(enumeration = "profile_event_content::ProfileEventType", tag = "1")]
    pub event_type: i32,
    #[prost(string, tag = "2")]
    pub new_value: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `ProfileEventContent`.
pub mod profile_event_content {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProfileEventType {
        EventUnknown = 0,
        EventName = 1,
        EventAvatar = 2,
        EventEmail = 3,
        EventPhone = 4,
        EventLogout = 5,
    }
    impl ProfileEventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::EventUnknown => "EVENT_UNKNOWN",
                Self::EventName => "EVENT_NAME",
                Self::EventAvatar => "EVENT_AVATAR",
                Self::EventEmail => "EVENT_EMAIL",
                Self::EventPhone => "EVENT_PHONE",
                Self::EventLogout => "EVENT_LOGOUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EVENT_UNKNOWN" => Some(Self::EventUnknown),
                "EVENT_NAME" => Some(Self::EventName),
                "EVENT_AVATAR" => Some(Self::EventAvatar),
                "EVENT_EMAIL" => Some(Self::EventEmail),
                "EVENT_PHONE" => Some(Self::EventPhone),
                "EVENT_LOGOUT" => Some(Self::EventLogout),
                _ => None,
            }
        }
    }
}
/// ===============================
/// ğŸ‘¥ ç¾¤ç»„äº‹ä»¶
/// ===============================
/// ç”¨äºç¾¤ç»„ç›¸å…³äº‹ä»¶ï¼ŒåŒ…å«ç¾¤ç»„ä¿¡æ¯å’Œæ“ä½œè€…
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupEventContent {
    /// ç¾¤ç»„ IDï¼šäº‹ä»¶ç›¸å…³çš„ç¾¤ç»„
    #[prost(int64, tag = "1")]
    pub group_id: i64,
    /// äº‹ä»¶â€œç±»å‹â€ï¼šæœºå™¨å¯è¯»
    #[prost(enumeration = "GroupEventType", tag = "2")]
    pub r#type: i32,
    /// æ“ä½œè€… IDï¼ˆç³»ç»Ÿäº‹ä»¶/å®šæ—¶ä»»åŠ¡å¯å¡« 0ï¼‰
    #[prost(int64, tag = "3")]
    pub operator_id: i64,
    /// äº‹ä»¶å‘ç”Ÿæ—¶é—´ï¼ˆç”¨äºå®¡è®¡/æ’åºï¼‰
    #[prost(int64, tag = "4")]
    pub at: i64,
    /// ç»Ÿä¸€å¯è§‚æµ‹ï¼šäººç±»å¯è¯»åŸå› ã€ç°åº¦æ ‡è®°ç­‰
    #[prost(string, tag = "6")]
    pub reason: ::prost::alloc::string::String,
    /// é™„åŠ  metadataï¼ˆç°åº¦å¼€å…³ã€æ¥æºç«¯ã€å®¢æˆ·ç«¯ç‰ˆæœ¬ç­‰ï¼‰
    #[prost(map = "string, string", tag = "7")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// å…³è”çš„ç”³è¯·/æ¶ˆæ¯/å·¥å•ç­‰ï¼ˆå¦‚å®¡æ‰¹ request_idã€å…¬å‘Šæ¶ˆæ¯ idï¼‰
    #[prost(uint64, optional, tag = "8")]
    pub ref_id: ::core::option::Option<u64>,
    /// å¹‚ç­‰è¿½è¸ª/é“¾è·¯æ’æŸ¥ï¼ˆå¦‚ ULID/UUIDï¼‰
    #[prost(string, tag = "9")]
    pub trace_id: ::prost::alloc::string::String,
    #[prost(
        oneof = "group_event_content::Payload",
        tags = "10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 99"
    )]
    pub payload: ::core::option::Option<group_event_content::Payload>,
}
/// Nested message and enum types in `GroupEventContent`.
pub mod group_event_content {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        /// æˆå‘˜å˜æ›´äº‹ä»¶ï¼ˆå…¥ç¾¤/é€€ç¾¤/è¸¢äºº/é‚€è¯·/å®¡æ‰¹ç­‰ï¼‰
        #[prost(message, tag = "10")]
        MemberChanged(super::GroupMemberChanged),
        /// æˆå‘˜è§’è‰²å˜æ›´ï¼ˆå‡é™çº§ã€è½¬è®©ç¾¤ä¸»ç­‰ï¼‰
        #[prost(message, tag = "11")]
        RoleChanged(super::GroupRoleChanged),
        /// ç¾¤èµ„æ–™æ›´æ–°ï¼ˆåç§°/å¤´åƒ/æè¿°ç­‰ï¼‰
        #[prost(message, tag = "12")]
        InfoUpdated(super::GroupInfoUpdated),
        /// æƒé™é…ç½®æ›´æ–°ï¼ˆåŠ ç¾¤ç­–ç•¥ã€é‚€è¯·æƒé™ç­‰ï¼‰
        #[prost(message, tag = "13")]
        PermissionUpdated(super::GroupPermissionUpdated),
        /// ç¦è¨€å¼€å…³æˆ–æˆå‘˜è¢«ç¦è¨€
        #[prost(message, tag = "14")]
        MuteChanged(super::GroupMuteChanged),
        /// æˆå‘˜è¢«å°ç¦/è§£é™¤å°ç¦
        #[prost(message, tag = "15")]
        BanChanged(super::GroupBanChanged),
        /// é‚€è¯·é“¾æ¥å˜æ›´
        #[prost(message, tag = "16")]
        InviteLinkUpdated(super::GroupInviteLinkUpdated),
        /// å…¬å‘Šå†…å®¹å˜æ›´
        #[prost(message, tag = "17")]
        AnnouncementUpdated(super::GroupAnnouncementUpdated),
        /// ç½®é¡¶æ¶ˆæ¯å˜æ›´ï¼ˆæ–°å¢/ç§»é™¤ï¼‰
        #[prost(message, tag = "18")]
        PinChanged(super::GroupPinChanged),
        /// å…¥ç¾¤/é€€ç¾¤äº‹ä»¶ï¼ˆä»…é¢å¤–åœºæ™¯ï¼‰
        #[prost(message, tag = "19")]
        JoinLeave(super::GroupJoinLeave),
        /// è‡ªå®šä¹‰äº‹ä»¶è´Ÿè½½ï¼ˆå¯æ‰©å±•ï¼‰
        #[prost(message, tag = "99")]
        Custom(super::GroupCustomEvent),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GroupMemberChanged {
    #[prost(enumeration = "group_member_changed::Action", tag = "1")]
    pub action: i32,
    #[prost(int64, tag = "2")]
    pub member_id: i64,
    #[prost(string, tag = "3")]
    pub member_alias: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub occurred_at: i64,
    #[prost(int64, repeated, tag = "5")]
    pub via_member_ids: ::prost::alloc::vec::Vec<i64>,
    #[prost(string, tag = "6")]
    pub note: ::prost::alloc::string::String,
}
/// Nested message and enum types in `GroupMemberChanged`.
pub mod group_member_changed {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        Unspecified = 0,
        Joined = 1,
        Left = 2,
        Kicked = 3,
        Invited = 4,
        Approved = 5,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ACTION_UNSPECIFIED",
                Self::Joined => "ACTION_JOINED",
                Self::Left => "ACTION_LEFT",
                Self::Kicked => "ACTION_KICKED",
                Self::Invited => "ACTION_INVITED",
                Self::Approved => "ACTION_APPROVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ACTION_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTION_JOINED" => Some(Self::Joined),
                "ACTION_LEFT" => Some(Self::Left),
                "ACTION_KICKED" => Some(Self::Kicked),
                "ACTION_INVITED" => Some(Self::Invited),
                "ACTION_APPROVED" => Some(Self::Approved),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GroupRoleChanged {
    #[prost(enumeration = "group_role_changed::RoleChangeType", tag = "1")]
    pub change_type: i32,
    #[prost(int64, tag = "2")]
    pub target_member_id: i64,
    #[prost(string, tag = "3")]
    pub previous_role: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub current_role: ::prost::alloc::string::String,
}
/// Nested message and enum types in `GroupRoleChanged`.
pub mod group_role_changed {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RoleChangeType {
        RoleChangeUnspecified = 0,
        RolePromoted = 1,
        RoleDemoted = 2,
        OwnerTransferred = 3,
    }
    impl RoleChangeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::RoleChangeUnspecified => "ROLE_CHANGE_UNSPECIFIED",
                Self::RolePromoted => "ROLE_PROMOTED",
                Self::RoleDemoted => "ROLE_DEMOTED",
                Self::OwnerTransferred => "OWNER_TRANSFERRED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ROLE_CHANGE_UNSPECIFIED" => Some(Self::RoleChangeUnspecified),
                "ROLE_PROMOTED" => Some(Self::RolePromoted),
                "ROLE_DEMOTED" => Some(Self::RoleDemoted),
                "OWNER_TRANSFERRED" => Some(Self::OwnerTransferred),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GroupInfoUpdated {
    /// å˜æ›´å‰ç¾¤åç§°ã€‚
    #[prost(string, tag = "1")]
    pub previous_name: ::prost::alloc::string::String,
    /// å˜æ›´åç¾¤åç§°ã€‚
    #[prost(string, tag = "2")]
    pub current_name: ::prost::alloc::string::String,
    /// å˜æ›´å‰ç¾¤å¤´åƒ URLã€‚
    #[prost(string, tag = "3")]
    pub previous_avatar: ::prost::alloc::string::String,
    /// å˜æ›´åç¾¤å¤´åƒ URLã€‚
    #[prost(string, tag = "4")]
    pub current_avatar: ::prost::alloc::string::String,
    /// å˜æ›´å‰ç¾¤ç®€ä»‹/æè¿°ã€‚
    #[prost(string, tag = "5")]
    pub previous_description: ::prost::alloc::string::String,
    /// å˜æ›´åç¾¤ç®€ä»‹/æè¿°ã€‚
    #[prost(string, tag = "6")]
    pub current_description: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupPermissionUpdated {
    /// å˜æ›´å‰çš„æƒé™é…ç½®ï¼ˆkey/value è¡¨ç¤ºæƒé™é¡¹å’Œå€¼ï¼‰ã€‚
    #[prost(map = "string, string", tag = "1")]
    pub previous_permissions: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// å˜æ›´åçš„æƒé™é…ç½®ã€‚
    #[prost(map = "string, string", tag = "2")]
    pub current_permissions: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GroupMuteChanged {
    /// æ˜¯å¦å¼€å¯å…¨å‘˜ç¦è¨€ã€‚
    #[prost(bool, tag = "1")]
    pub enable_all_mute: bool,
    /// é’ˆå¯¹çš„æˆå‘˜ IDï¼ˆè‹¥é’ˆå¯¹ä¸ªäººç¦è¨€ï¼‰ã€‚
    #[prost(int64, tag = "2")]
    pub target_member_id: i64,
    /// ç¦è¨€ç»“æŸæ—¶é—´ã€‚
    #[prost(int64, tag = "3")]
    pub mute_until: i64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GroupBanChanged {
    /// è¢«å°ç¦æˆå‘˜ IDã€‚
    #[prost(int64, tag = "1")]
    pub member_id: i64,
    /// å°ç¦ç»“æŸæ—¶é—´ã€‚
    #[prost(int64, tag = "2")]
    pub banned_until: i64,
    /// å°ç¦åŸå› ã€‚
    #[prost(string, tag = "3")]
    pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GroupInviteLinkUpdated {
    /// é‚€è¯·é“¾æ¥æ˜¯å¦å¯ç”¨ã€‚
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    /// é“¾æ¥åœ°å€ã€‚
    #[prost(string, tag = "2")]
    pub link: ::prost::alloc::string::String,
    /// é“¾æ¥åˆ·æ–°æ—¶é—´ã€‚
    #[prost(int64, tag = "3")]
    pub refreshed_at: i64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GroupAnnouncementUpdated {
    /// æ¶ˆæ¯ IDï¼ˆå¦‚æœå…¬å‘Šæ¥è‡ªæŸæ¡æ¶ˆæ¯ï¼‰ã€‚
    #[prost(uint64, tag = "1")]
    pub message_id: u64,
    /// å˜æ›´å‰å†…å®¹ã€‚
    #[prost(string, tag = "2")]
    pub previous_announcement: ::prost::alloc::string::String,
    /// å½“å‰å…¬å‘Šå†…å®¹ã€‚
    #[prost(string, tag = "3")]
    pub current_announcement: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GroupPinChanged {
    /// ç½®é¡¶æ¡ç›® IDã€‚
    #[prost(string, tag = "1")]
    pub pin_id: ::prost::alloc::string::String,
    /// æ˜¯å¦è¢«ç½®é¡¶ã€‚
    #[prost(bool, tag = "2")]
    pub pinned: bool,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GroupJoinLeave {
    /// äº‹ä»¶ç±»å‹ã€‚
    #[prost(enumeration = "group_join_leave::MemberEvent", tag = "1")]
    pub event: i32,
    /// å˜åŠ¨æˆå‘˜ IDã€‚
    #[prost(int64, tag = "2")]
    pub member_id: i64,
}
/// Nested message and enum types in `GroupJoinLeave`.
pub mod group_join_leave {
    /// æè¿°æˆå‘˜è¿›å…¥/é€€å‡ºç¾¤çš„äº‹ä»¶ç±»å‹ã€‚
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MemberEvent {
        /// é»˜è®¤å€¼ï¼Œè¡¨ç¤ºæœªæŒ‡å®šå…·ä½“äº‹ä»¶ã€‚
        Unspecified = 0,
        /// æˆå‘˜ä¸»åŠ¨ç¦»å¼€ç¾¤ç»„ã€‚
        Left = 1,
        /// æˆå‘˜è¢«ç®¡ç†å‘˜æˆ–ç³»ç»Ÿç§»é™¤ã€‚
        Removed = 2,
    }
    impl MemberEvent {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MEMBER_EVENT_UNSPECIFIED",
                Self::Left => "MEMBER_EVENT_LEFT",
                Self::Removed => "MEMBER_EVENT_REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MEMBER_EVENT_UNSPECIFIED" => Some(Self::Unspecified),
                "MEMBER_EVENT_LEFT" => Some(Self::Left),
                "MEMBER_EVENT_REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GroupCustomEvent {
    #[prost(string, tag = "1")]
    pub label: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub data: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ“‡ åç‰‡æ¶ˆæ¯
/// ===============================
/// ç”¨äºåˆ†äº«è”ç³»äººä¿¡æ¯ï¼ŒåŒ…å«ç”¨æˆ·çš„åŸºæœ¬ä¿¡æ¯
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ContactCardContent {
    /// ç›®æ ‡ IDï¼šè¢«åˆ†äº«ç”¨æˆ·çš„ID
    #[prost(string, tag = "1")]
    pub target_id: ::prost::alloc::string::String,
    /// æ˜¾ç¤ºåç§°ï¼šç”¨æˆ·çš„æ˜¾ç¤ºåç§°
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// å¤´åƒ URLï¼šç”¨æˆ·çš„å¤´åƒåœ°å€
    #[prost(string, tag = "3")]
    pub avatar_url: ::prost::alloc::string::String,
    /// å¡ç‰‡ç±»å‹ï¼šåç‰‡çš„ç±»å‹ï¼ˆç”¨æˆ·/ç¾¤ç»„ï¼‰
    #[prost(string, tag = "4")]
    pub card_type: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ“Š æŠ•ç¥¨æ¶ˆæ¯
/// ===============================
/// ç”¨äºç¾¤ç»„æŠ•ç¥¨åŠŸèƒ½ï¼ŒåŒ…å«æŠ•ç¥¨é€‰é¡¹å’Œç»“æœ
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VoteContent {
    /// ä¸»é¢˜ï¼šæŠ•ç¥¨çš„ä¸»é¢˜
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    /// é€‰é¡¹ï¼šæŠ•ç¥¨çš„é€‰é¡¹åˆ—è¡¨
    #[prost(string, repeated, tag = "2")]
    pub options: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// ç»“æœï¼šæŠ•ç¥¨ç»“æœç»Ÿè®¡
    #[prost(map = "string, int32", tag = "3")]
    pub result: ::std::collections::HashMap<::prost::alloc::string::String, i32>,
    /// å¤šé€‰ï¼šæ˜¯å¦å…è®¸å¤šé€‰
    #[prost(bool, tag = "4")]
    pub multi_choice: bool,
}
/// ===============================
/// ğŸ’° çº¢åŒ…æ¶ˆæ¯
/// ===============================
/// ç”¨äºçº¢åŒ…åŠŸèƒ½ï¼ŒåŒ…å«çº¢åŒ…é‡‘é¢å’ŒçŠ¶æ€
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RedEnvelopeContent {
    /// å‘é€è€… IDï¼šçº¢åŒ…å‘é€è€…
    #[prost(int64, tag = "1")]
    pub sender_id: i64,
    /// é‡‘é¢ï¼šçº¢åŒ…é‡‘é¢ï¼ˆåˆ†ï¼‰
    #[prost(int32, tag = "2")]
    pub amount: i32,
    /// ç¥ç¦è¯­ï¼šçº¢åŒ…çš„ç¥ç¦è¯­
    #[prost(string, tag = "3")]
    pub blessing: ::prost::alloc::string::String,
    /// æ˜¯å¦å·²é¢†å–ï¼šçº¢åŒ…æ˜¯å¦å·²è¢«é¢†å–
    #[prost(bool, tag = "4")]
    pub claimed: bool,
}
/// ======================================
/// âœ‚ï¸ Segment - æ¶ˆæ¯æ®µç»“æ„ï¼ˆç”¨äºå¤åˆå†…å®¹ï¼‰
/// ======================================
/// è¡¨ç¤ºä¸€æ¡æ¶ˆæ¯ä¸­çš„ä¸€ä¸ªç‹¬ç«‹æ®µï¼ˆå¦‚æ–‡æœ¬æ®µã€å›¾ç‰‡æ®µç­‰ï¼‰ï¼Œæ”¯æŒæ’åºã€ç¼–è¾‘ã€æ ‡è®°ç­‰
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Segment {
    /// æ¶ˆæ¯æ®µå†…å®¹ï¼ˆå¦‚æ–‡æœ¬ã€å›¾ç‰‡ç­‰ï¼Œä½¿ç”¨ oneof å°è£…ï¼‰ï¼šæ®µçš„å…·ä½“å†…å®¹
    #[prost(message, optional, tag = "1")]
    pub body: ::core::option::Option<MessageContent>,
    /// æ¶ˆæ¯å†…é¡ºåºç¼–å·ï¼ˆç”¨äºå‰ç«¯æ¸²æŸ“æ’åºï¼‰ï¼šæ®µåœ¨æ¶ˆæ¯ä¸­çš„é¡ºåº
    #[prost(uint64, tag = "2")]
    pub seq_in_msg: u64,
    /// é€šç”¨æ‰©å±•å­—æ®µï¼ˆä»¥å­—ç¬¦ä¸²é”®å€¼å¯¹å­˜å‚¨ JSON æ‰å¹³æ•°æ®ï¼‰ï¼šæ®µçš„å…ƒæ•°æ®
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// ======================================
/// ğŸ“¨ é¡¶å±‚æ¶ˆæ¯ç»“æ„
/// ======================================
/// å®šä¹‰äº†æ¶ˆæ¯çš„åŸºæœ¬æ¡†æ¶ï¼ŒåŒ…å«å‘é€è€…ã€æ¥æ”¶è€…ã€æ—¶é—´ç­‰å…ƒæ•°æ®
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Content {
    /// å”¯ä¸€æ¶ˆæ¯ IDï¼ˆå®¢æˆ·ç«¯ç”Ÿæˆæˆ–æœåŠ¡ç«¯è¡¥å…¨ï¼‰ï¼šæ¶ˆæ¯çš„å”¯ä¸€æ ‡è¯†
    #[prost(uint64, optional, tag = "1")]
    pub message_id: ::core::option::Option<u64>,
    /// æ¶ˆæ¯å‘é€æ–¹ï¼šå‘é€æ¶ˆæ¯çš„ç”¨æˆ·ID
    #[prost(int64, tag = "2")]
    pub sender_id: i64,
    /// æ¶ˆæ¯æ¥æ”¶æ–¹ï¼ˆå•èŠä¸ºå¯¹æ–¹ IDï¼Œç¾¤èŠä¸ºç¾¤ IDï¼‰ï¼šæ¥æ”¶æ¶ˆæ¯çš„ç›®æ ‡
    #[prost(int64, tag = "3")]
    pub receiver_id: i64,
    /// æ¶ˆæ¯å‘é€æ—¶é—´ï¼ˆæ¯«ç§’æ—¶é—´æˆ³ï¼‰ï¼šæ¶ˆæ¯åˆ›å»ºçš„æ—¶é—´
    #[prost(int64, tag = "4")]
    pub timestamp: i64,
    /// æ¶ˆæ¯æ‰€å±ä¼šè¯ç±»å‹ï¼ˆå•èŠ/ç¾¤èŠï¼‰ï¼šæ¶ˆæ¯çš„ä¼šè¯åœºæ™¯
    #[prost(enumeration = "ChatScene", tag = "6")]
    pub scene: i32,
    /// å¤šæ®µå¤åˆå†…å®¹ï¼ˆå¦‚æ–‡æœ¬ + å›¾ç‰‡ï¼‰ï¼šæ¶ˆæ¯çš„å…·ä½“å†…å®¹
    #[prost(message, repeated, tag = "10")]
    pub contents: ::prost::alloc::vec::Vec<MessageContent>,
    /// å¥½å‹ç”³è¯·/å—ç†ä¸šåŠ¡è½½è·ï¼ˆé¡¶å±‚ç›´æ¥è¡¨å¾ï¼‰
    #[prost(message, optional, tag = "11")]
    pub friend_business: ::core::option::Option<FriendBusinessContent>,
    /// ç¾¤ç”³è¯·/å—ç†ä¸šåŠ¡è½½è·
    #[prost(message, optional, tag = "12")]
    pub group_business: ::core::option::Option<GroupBusinessContent>,
    /// æ ‡è®°ï¼šè¡¨ç¤ºè¯¥å¸§ä»…ç”¨äºè¿æ¥ä¿æ´»ï¼ˆå¿ƒè·³ï¼‰
    #[prost(bool, optional, tag = "13")]
    pub heartbeat: ::core::option::Option<bool>,
    /// é€šç”¨ä¸šåŠ¡ç¡®è®¤/é€šçŸ¥ï¼ˆå¤„ç†ç»“æœå›æ‰§ï¼‰
    #[prost(message, optional, tag = "23")]
    pub ack: ::core::option::Option<AckContent>,
    /// ç³»ç»Ÿä¸šåŠ¡é€šçŸ¥ï¼šå¯æ‰¿è½½ç³»ç»Ÿäº‹ä»¶/ä»»åŠ¡æ‰§è¡Œç»“æœ
    #[prost(message, optional, tag = "25")]
    pub system_business: ::core::option::Option<SystemBusinessContent>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeliveryOptions {
    #[prost(bool, tag = "1")]
    pub require_ack: bool,
    #[prost(uint64, optional, tag = "2")]
    pub expire_ms: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub max_retry: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DomainMessage {
    #[prost(uint64, optional, tag = "1")]
    pub message_id: ::core::option::Option<u64>,
    #[prost(int64, tag = "2")]
    pub sender_id: i64,
    #[prost(int64, tag = "3")]
    pub receiver_id: i64,
    #[prost(int64, tag = "4")]
    pub timestamp: i64,
    #[prost(int64, tag = "5")]
    pub ts_ms: i64,
    #[prost(message, optional, tag = "6")]
    pub delivery: ::core::option::Option<DeliveryOptions>,
    #[prost(enumeration = "ChatScene", tag = "7")]
    pub scene: i32,
    #[prost(enumeration = "MsgCategory", tag = "8")]
    pub category: i32,
    #[prost(message, repeated, tag = "9")]
    pub contents: ::prost::alloc::vec::Vec<MessageContent>,
    #[prost(message, optional, tag = "10")]
    pub friend_business: ::core::option::Option<FriendBusinessContent>,
    #[prost(message, optional, tag = "11")]
    pub group_business: ::core::option::Option<GroupBusinessContent>,
}
/// å‘èµ·å‘¼å«ï¼ˆå¸¦ SDP offerï¼‰
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CallInvite {
    /// é€šè¯IDï¼ˆå…¨å±€å”¯ä¸€å­—ç¬¦ä¸²/é›ªèŠ±ï¼‰
    #[prost(string, tag = "1")]
    pub call_id: ::prost::alloc::string::String,
    /// ä¸»å«ç”¨æˆ·ID
    #[prost(int64, tag = "2")]
    pub from_user_id: i64,
    /// è¢«å«ç”¨æˆ·ID
    #[prost(int64, tag = "3")]
    pub to_user_id: i64,
    /// åª’ä½“ç±»å‹ï¼ˆè¯­éŸ³/è§†é¢‘ï¼‰
    #[prost(enumeration = "CallMediaType", tag = "4")]
    pub media_type: i32,
    /// SDP offerï¼ˆè‹¥ä½¿ç”¨ WebRTCï¼‰
    #[prost(string, tag = "5")]
    pub sdp_offer: ::prost::alloc::string::String,
    /// æ‰©å±•å­—æ®µ
    #[prost(string, optional, tag = "6")]
    pub ext: ::core::option::Option<::prost::alloc::string::String>,
    /// å‘èµ·æ—¶é—´
    #[prost(uint64, tag = "7")]
    pub created_at: u64,
}
/// å–æ¶ˆå‘¼å«ï¼ˆæŒ¯é“ƒé˜¶æ®µï¼‰
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CallCancel {
    /// é€šè¯ID
    #[prost(string, tag = "1")]
    pub call_id: ::prost::alloc::string::String,
    /// æ“ä½œè€…
    #[prost(int64, tag = "2")]
    pub operator_user_id: i64,
    /// åŸå› ï¼ˆå¯é€‰ï¼‰
    #[prost(string, optional, tag = "3")]
    pub reason: ::core::option::Option<::prost::alloc::string::String>,
    /// æ—¶é—´
    #[prost(uint64, tag = "4")]
    pub at: u64,
}
/// æ‹’ç»å‘¼å«
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CallReject {
    /// é€šè¯ID
    #[prost(string, tag = "1")]
    pub call_id: ::prost::alloc::string::String,
    /// æ‹’ç»è€…
    #[prost(int64, tag = "2")]
    pub reject_user_id: i64,
    /// åŸå› ï¼ˆå¯é€‰ï¼‰
    #[prost(string, optional, tag = "3")]
    pub reason: ::core::option::Option<::prost::alloc::string::String>,
    /// æ—¶é—´
    #[prost(uint64, tag = "4")]
    pub at: u64,
}
/// æ¥å—å‘¼å«ï¼ˆå¸¦ SDP answerï¼‰
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CallAccept {
    /// é€šè¯ID
    #[prost(string, tag = "1")]
    pub call_id: ::prost::alloc::string::String,
    /// æ¥å—è€…
    #[prost(int64, tag = "2")]
    pub accept_user_id: i64,
    /// SDP answerï¼ˆè‹¥ä½¿ç”¨ WebRTCï¼‰
    #[prost(string, tag = "3")]
    pub sdp_answer: ::prost::alloc::string::String,
    /// æ—¶é—´
    #[prost(uint64, tag = "4")]
    pub at: u64,
}
/// é€šè¯ç»“æŸ/æŒ‚æ–­
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CallHangup {
    /// é€šè¯ID
    #[prost(string, tag = "1")]
    pub call_id: ::prost::alloc::string::String,
    /// æ“ä½œè€…
    #[prost(int64, tag = "2")]
    pub operator_user_id: i64,
    /// ç»“æŸåŸå› 
    #[prost(enumeration = "CallEndReason", tag = "3")]
    pub reason: i32,
    /// é€šè¯æ—¶é•¿ï¼ˆæ¯«ç§’ï¼Œå¯é€‰ï¼‰
    #[prost(uint64, optional, tag = "4")]
    pub duration_ms: ::core::option::Option<u64>,
    /// æ—¶é—´
    #[prost(uint64, tag = "5")]
    pub at: u64,
}
/// é€šè¯ä¸­ä¿®æ”¹ï¼ˆé™éŸ³/å¼€å…³æ‘„åƒå¤´ç­‰ï¼‰
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CallModify {
    /// é€šè¯ID
    #[prost(string, tag = "1")]
    pub call_id: ::prost::alloc::string::String,
    /// æ“ä½œè€…
    #[prost(int64, tag = "2")]
    pub operator_user_id: i64,
    /// ä¿®æ”¹ç±»å‹
    #[prost(enumeration = "CallModifyType", tag = "3")]
    pub modify: i32,
    /// å¼€å…³å€¼ï¼ˆtrue=å¼€/å¯ç”¨ï¼Œfalse=å…³/ç¦ç”¨ï¼‰
    #[prost(bool, tag = "4")]
    pub on: bool,
    /// æ—¶é—´
    #[prost(uint64, tag = "5")]
    pub at: u64,
}
/// DTMF ä¿¡ä»¤
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CallDtmf {
    /// é€šè¯ID
    #[prost(string, tag = "1")]
    pub call_id: ::prost::alloc::string::String,
    /// å‘é€è€…
    #[prost(int64, tag = "2")]
    pub from_user_id: i64,
    /// DTMF æŒ‰é”®åºåˆ—ï¼ˆå¦‚ "123#*")
    #[prost(string, tag = "3")]
    pub digits: ::prost::alloc::string::String,
    /// æ—¶é—´
    #[prost(uint64, tag = "4")]
    pub at: u64,
}
/// é€è¾¾å›æ‰§ç¡®è®¤ï¼ˆå®¢æˆ·ç«¯â†’æœåŠ¡ç«¯ï¼šæ”¶åˆ° deliveredï¼‰
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MsgDeliveredAck {
    #[prost(int64, tag = "1")]
    pub msg_id: i64,
    #[prost(int64, tag = "2")]
    pub ack_user_id: i64,
    #[prost(int64, tag = "3")]
    pub ack_at: i64,
}
/// å·²è¯»ä¸ŠæŠ¥ï¼ˆå®¢æˆ·ç«¯â†’æœåŠ¡ç«¯ï¼‰
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MsgRead {
    #[prost(int64, tag = "1")]
    pub msg_id: i64,
    #[prost(int64, tag = "2")]
    pub uid: i64,
    /// å•èŠï¼šå¯¹æ–¹IDï¼›ç¾¤èŠï¼šç¾¤ID
    #[prost(int64, tag = "3")]
    pub chat_id: i64,
    #[prost(int64, tag = "4")]
    pub read_at: i64,
}
/// å·²è¯»å›æ‰§ç¡®è®¤ï¼ˆæœåŠ¡ç«¯â†’å®¢æˆ·ç«¯ï¼šæ”¶åˆ° readï¼‰
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MsgReadAck {
    #[prost(int64, tag = "1")]
    pub msg_id: i64,
    #[prost(int64, tag = "2")]
    pub ack_user_id: i64,
    #[prost(int64, tag = "3")]
    pub ack_at: i64,
}
/// æ¶ˆæ¯æ’¤å›
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MsgRecall {
    #[prost(int64, tag = "1")]
    pub msg_id: i64,
    #[prost(int64, tag = "2")]
    pub operator_user_id: i64,
    #[prost(string, optional, tag = "3")]
    pub reason: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, tag = "4")]
    pub recalled_at: i64,
}
/// æ¶ˆæ¯è½¬å‘
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MsgForward {
    #[prost(int64, tag = "1")]
    pub src_msg_id: i64,
    #[prost(int64, optional, tag = "2")]
    pub new_msg_id: ::core::option::Option<i64>,
    #[prost(int64, tag = "3")]
    pub from_user_id: i64,
    #[prost(int64, tag = "4")]
    pub to_user_id: i64,
    #[prost(int64, tag = "5")]
    pub created_at: i64,
}
/// æ¶ˆæ¯è¡¨æ€ï¼ˆemoji/reactionï¼‰
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MsgReaction {
    #[prost(int64, tag = "1")]
    pub msg_id: i64,
    #[prost(int64, tag = "2")]
    pub uid: i64,
    #[prost(enumeration = "ReactionAction", tag = "3")]
    pub action: i32,
    #[prost(string, tag = "4")]
    pub emoji: ::prost::alloc::string::String,
    #[prost(int64, tag = "5")]
    pub at: i64,
}
/// æ­£åœ¨è¾“å…¥
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Typing {
    #[prost(int64, tag = "1")]
    pub from_user_id: i64,
    #[prost(enumeration = "TypingState", tag = "3")]
    pub state: i32,
    #[prost(int64, tag = "4")]
    pub at: i64,
    #[prost(int64, repeated, tag = "6")]
    pub notify_user_ids: ::prost::alloc::vec::Vec<i64>,
    #[prost(oneof = "typing::Target", tags = "2, 5")]
    pub target: ::core::option::Option<typing::Target>,
}
/// Nested message and enum types in `Typing`.
pub mod typing {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Target {
        #[prost(int64, tag = "2")]
        ToUserId(i64),
        #[prost(int64, tag = "5")]
        GroupId(i64),
    }
}
/// æŸ¥è¯¢å¥½å‹æ¶ˆæ¯å†å²
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryFriendMessagesRequest {
    /// å½“å‰ç”¨æˆ· ID
    #[prost(int64, tag = "1")]
    pub uid: i64,
    /// å¥½å‹ ID
    #[prost(int64, tag = "2")]
    pub friend_id: i64,
    /// åˆ†é¡µæ¸¸æ ‡ï¼šæ¶ˆæ¯ ID ä¸Šé™ï¼ˆä¸å«ï¼‰
    #[prost(uint64, optional, tag = "3")]
    pub before_message_id: ::core::option::Option<u64>,
    /// åˆ†é¡µæ¸¸æ ‡ï¼šæ—¶é—´ä¸Šé™ï¼ˆæ¯«ç§’ï¼Œä¸å«ï¼‰
    #[prost(int64, optional, tag = "4")]
    pub before_timestamp: ::core::option::Option<i64>,
    /// è¿”å›æ¡ç›®ä¸Šé™ï¼Œç¼ºçœ 20
    #[prost(uint32, tag = "5")]
    pub limit: u32,
}
/// æŸ¥è¯¢ç¾¤èŠæ¶ˆæ¯å†å²
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryGroupMessagesRequest {
    /// ç¾¤ ID
    #[prost(int64, tag = "1")]
    pub group_id: i64,
    /// åˆ†é¡µæ¸¸æ ‡ï¼šæ¶ˆæ¯ ID ä¸Šé™ï¼ˆä¸å«ï¼‰
    #[prost(uint64, optional, tag = "2")]
    pub before_message_id: ::core::option::Option<u64>,
    /// åˆ†é¡µæ¸¸æ ‡ï¼šæ—¶é—´ä¸Šé™ï¼ˆæ¯«ç§’ï¼Œä¸å«ï¼‰
    #[prost(int64, optional, tag = "3")]
    pub before_timestamp: ::core::option::Option<i64>,
    /// è¿”å›æ¡ç›®ä¸Šé™ï¼Œç¼ºçœ 20
    #[prost(uint32, tag = "4")]
    pub limit: u32,
}
/// å†å²æ¶ˆæ¯æŸ¥è¯¢ç»Ÿä¸€å“åº”
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryMessagesResponse {
    /// æ¶ˆæ¯åˆ—è¡¨ï¼ˆæŒ‰æ—¶é—´å€’åºæˆ–åº”ç”¨çº¦å®šæ’åºï¼‰
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Content>,
    /// æ˜¯å¦è¿˜æœ‰æ›´å¤šæ•°æ®
    #[prost(bool, tag = "2")]
    pub has_more: bool,
}
/// ======================================
/// ğŸ˜„ Emoji ç±»å‹å®šä¹‰ï¼ˆæ ‡å‡† + è‡ªå®šä¹‰ï¼‰
/// ======================================
/// å®šä¹‰äº†ç³»ç»Ÿä¸­æ”¯æŒçš„ emoji ç±»å‹ï¼ŒåŒ…æ‹¬æ ‡å‡† emoji å’Œè‡ªå®šä¹‰è¡¨æƒ…
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EmojiType {
    EmojiUnknown = 0,
    /// å¾®ç¬‘è¡¨æƒ…
    Smile = 1,
    /// å’§å˜´ç¬‘è¡¨æƒ…
    Grin = 2,
    /// æµæ³ªè¡¨æƒ…
    Tears = 3,
    /// åèˆŒå¤´è¡¨æƒ…
    StuckOutTongue = 4,
    /// é¼“æŒè¡¨æƒ…
    Clap = 25,
    /// ä¾¿ä¾¿è¡¨æƒ…
    Poop = 28,
    /// çˆ±å¿ƒè¡¨æƒ…
    Heart = 21,
    /// ... å¯ç»§ç»­æ‰©å±•æ ‡å‡† Emoji
    /// è‡ªå®šä¹‰è¡¨æƒ…ï¼ˆé€šè¿‡å›¾ç‰‡ URL æŒ‡å®šï¼‰
    CustomEmoji = 1000,
}
impl EmojiType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::EmojiUnknown => "EMOJI_UNKNOWN",
            Self::Smile => "SMILE",
            Self::Grin => "GRIN",
            Self::Tears => "TEARS",
            Self::StuckOutTongue => "STUCK_OUT_TONGUE",
            Self::Clap => "CLAP",
            Self::Poop => "POOP",
            Self::Heart => "HEART",
            Self::CustomEmoji => "CUSTOM_EMOJI",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EMOJI_UNKNOWN" => Some(Self::EmojiUnknown),
            "SMILE" => Some(Self::Smile),
            "GRIN" => Some(Self::Grin),
            "TEARS" => Some(Self::Tears),
            "STUCK_OUT_TONGUE" => Some(Self::StuckOutTongue),
            "CLAP" => Some(Self::Clap),
            "POOP" => Some(Self::Poop),
            "HEART" => Some(Self::Heart),
            "CUSTOM_EMOJI" => Some(Self::CustomEmoji),
            _ => None,
        }
    }
}
/// é€šè¯åª’ä½“ç±»å‹
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CallMediaType {
    /// è¯­éŸ³
    CallAudio = 0,
    /// è§†é¢‘
    CallVideo = 1,
}
impl CallMediaType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CallAudio => "CALL_AUDIO",
            Self::CallVideo => "CALL_VIDEO",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CALL_AUDIO" => Some(Self::CallAudio),
            "CALL_VIDEO" => Some(Self::CallVideo),
            _ => None,
        }
    }
}
/// é€šè¯ç»“æŸåŸå› 
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CallEndReason {
    /// æœªæŒ‡å®š
    CerUnspecified = 0,
    /// ä¸»åŠ¨å–æ¶ˆ
    CerCancelled = 1,
    /// å¯¹æ–¹æ‹’ç»
    CerRejected = 2,
    /// å¯¹æ–¹å¿™
    CerBusy = 3,
    /// è¶…æ—¶æœªåº”ç­”
    CerTimeout = 4,
    /// æ­£å¸¸æŒ‚æ–­
    CerHangup = 5,
    /// å¤±è´¥/å¼‚å¸¸
    CerFailed = 6,
}
impl CallEndReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CerUnspecified => "CER_UNSPECIFIED",
            Self::CerCancelled => "CER_CANCELLED",
            Self::CerRejected => "CER_REJECTED",
            Self::CerBusy => "CER_BUSY",
            Self::CerTimeout => "CER_TIMEOUT",
            Self::CerHangup => "CER_HANGUP",
            Self::CerFailed => "CER_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CER_UNSPECIFIED" => Some(Self::CerUnspecified),
            "CER_CANCELLED" => Some(Self::CerCancelled),
            "CER_REJECTED" => Some(Self::CerRejected),
            "CER_BUSY" => Some(Self::CerBusy),
            "CER_TIMEOUT" => Some(Self::CerTimeout),
            "CER_HANGUP" => Some(Self::CerHangup),
            "CER_FAILED" => Some(Self::CerFailed),
            _ => None,
        }
    }
}
/// é€šè¯å†…ä¿®æ”¹ç±»å‹
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CallModifyType {
    /// æœªæŒ‡å®šï¼Œç”¨ä½œé»˜è®¤å€¼ï¼Œæ»¡è¶³ proto3 é¦–å…ƒç´ ä¸º 0 çš„è¦æ±‚
    CmtUnspecified = 0,
    /// é™éŸ³/å–æ¶ˆé™éŸ³
    CmtMute = 1,
    /// å¼€/å…³æ‘„åƒå¤´
    CmtCamera = 2,
    /// ä¿æŒ/æ¢å¤é€šè¯
    CmtHold = 3,
    /// åˆ‡æ¢å‰åæ‘„
    CmtSwitchCamera = 4,
}
impl CallModifyType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CmtUnspecified => "CMT_UNSPECIFIED",
            Self::CmtMute => "CMT_MUTE",
            Self::CmtCamera => "CMT_CAMERA",
            Self::CmtHold => "CMT_HOLD",
            Self::CmtSwitchCamera => "CMT_SWITCH_CAMERA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CMT_UNSPECIFIED" => Some(Self::CmtUnspecified),
            "CMT_MUTE" => Some(Self::CmtMute),
            "CMT_CAMERA" => Some(Self::CmtCamera),
            "CMT_HOLD" => Some(Self::CmtHold),
            "CMT_SWITCH_CAMERA" => Some(Self::CmtSwitchCamera),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChatScene {
    /// é»˜è®¤æœªçŸ¥åœºæ™¯ï¼ˆé˜²å¾¡å€¼ï¼‰
    ChatUnknown = 0,
    /// å•äººä¼šè¯ï¼šç”¨æˆ·ä¸ç”¨æˆ·ä¹‹é—´çš„ç§èŠ
    Single = 1,
    /// ç¾¤èŠä¼šè¯ï¼šç¾¤ç»„å†…çš„å¤šäººèŠå¤©
    Group = 2,
    /// èµ„æ–™/ç³»ç»Ÿäº‹ä»¶ä¼šè¯
    Profile = 3,
}
impl ChatScene {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ChatUnknown => "CHAT_UNKNOWN",
            Self::Single => "SINGLE",
            Self::Group => "GROUP",
            Self::Profile => "PROFILE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHAT_UNKNOWN" => Some(Self::ChatUnknown),
            "SINGLE" => Some(Self::Single),
            "GROUP" => Some(Self::Group),
            "PROFILE" => Some(Self::Profile),
            _ => None,
        }
    }
}
/// å¥½å‹ç”³è¯·æ¥æº
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FriendRequestSource {
    /// æœªçŸ¥æ¥æº
    FrsUnknown = 0,
    /// äºŒç»´ç æ·»åŠ 
    FrsQrCode = 1,
    /// æ‰‹æœºè”ç³»äºº
    FrsPhoneContacts = 2,
    /// ç”¨æˆ·IDæ·»åŠ 
    FrsUserId = 3,
    /// ç¾¤æˆå‘˜æ·»åŠ 
    FrsGroupMember = 4,
}
impl FriendRequestSource {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::FrsUnknown => "FRS_UNKNOWN",
            Self::FrsQrCode => "FRS_QR_CODE",
            Self::FrsPhoneContacts => "FRS_PHONE_CONTACTS",
            Self::FrsUserId => "FRS_USER_ID",
            Self::FrsGroupMember => "FRS_GROUP_MEMBER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FRS_UNKNOWN" => Some(Self::FrsUnknown),
            "FRS_QR_CODE" => Some(Self::FrsQrCode),
            "FRS_PHONE_CONTACTS" => Some(Self::FrsPhoneContacts),
            "FRS_USER_ID" => Some(Self::FrsUserId),
            "FRS_GROUP_MEMBER" => Some(Self::FrsGroupMember),
            _ => None,
        }
    }
}
/// ===============================
/// ğŸ¤ å¥½å‹äº‹ä»¶
/// ===============================
/// ç”¨äºåŒæ­¥å¥½å‹åˆ«å/å¤‡æ³¨å˜æ›´ç­‰å…¸å‹äº‹ä»¶
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FriendEventType {
    FeUnspecified = 0,
    /// å¥½å‹åˆ«åæ›´æ–°ï¼ˆoperator_id ä¸ºå‘èµ·äººï¼‰
    FeAliasUpdated = 1,
    /// å¥½å‹å¤‡æ³¨æ›´æ–°
    FeRemarkUpdated = 2,
    /// å¥½å‹è¢«æ‹‰é»‘/è§£é™¤é»‘åå•
    FeBlacklistUpdated = 3,
}
impl FriendEventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::FeUnspecified => "FE_UNSPECIFIED",
            Self::FeAliasUpdated => "FE_ALIAS_UPDATED",
            Self::FeRemarkUpdated => "FE_REMARK_UPDATED",
            Self::FeBlacklistUpdated => "FE_BLACKLIST_UPDATED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FE_UNSPECIFIED" => Some(Self::FeUnspecified),
            "FE_ALIAS_UPDATED" => Some(Self::FeAliasUpdated),
            "FE_REMARK_UPDATED" => Some(Self::FeRemarkUpdated),
            "FE_BLACKLIST_UPDATED" => Some(Self::FeBlacklistUpdated),
            _ => None,
        }
    }
}
/// ç³»ç»Ÿä¸šåŠ¡ç±»å‹æšä¸¾ï¼Œä¾¿äºå„ç«¯é€šè¿‡ä¸šåŠ¡ç»„è¯†åˆ«åœºæ™¯ã€‚
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SystemBusinessType {
    /// é»˜è®¤å€¼ï¼šæœªçŸ¥/æœªåˆ†ç±»
    SystemBusinessUnknown = 0,
    /// ç»´æŠ¤ç›¸å…³ä»»åŠ¡ï¼ˆæš‚åœæœåŠ¡ã€å‡çº§ç­‰ï¼‰
    SystemBusinessMaintenance = 1,
    /// å‘Šè­¦/é£é™©é€šçŸ¥
    SystemBusinessAlert = 2,
    /// å‡çº§/è¿ç§»/åŠŸèƒ½ä¸Šçº¿
    SystemBusinessUpgrade = 3,
    /// ç­–ç•¥/è§„åˆ™è°ƒæ•´ã€æƒé™å˜æ›´ç­‰
    SystemBusinessPolicy = 4,
    /// è´¦æˆ·åœ¨å…¶å®ƒè®¾å¤‡/åœ°ç‚¹ä¸Šçº¿ï¼Œè¢«åŠ¨ä¸‹çº¿é€šçŸ¥
    SystemBusinessPassiveLogout = 5,
}
impl SystemBusinessType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SystemBusinessUnknown => "SYSTEM_BUSINESS_UNKNOWN",
            Self::SystemBusinessMaintenance => "SYSTEM_BUSINESS_MAINTENANCE",
            Self::SystemBusinessAlert => "SYSTEM_BUSINESS_ALERT",
            Self::SystemBusinessUpgrade => "SYSTEM_BUSINESS_UPGRADE",
            Self::SystemBusinessPolicy => "SYSTEM_BUSINESS_POLICY",
            Self::SystemBusinessPassiveLogout => "SYSTEM_BUSINESS_PASSIVE_LOGOUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SYSTEM_BUSINESS_UNKNOWN" => Some(Self::SystemBusinessUnknown),
            "SYSTEM_BUSINESS_MAINTENANCE" => Some(Self::SystemBusinessMaintenance),
            "SYSTEM_BUSINESS_ALERT" => Some(Self::SystemBusinessAlert),
            "SYSTEM_BUSINESS_UPGRADE" => Some(Self::SystemBusinessUpgrade),
            "SYSTEM_BUSINESS_POLICY" => Some(Self::SystemBusinessPolicy),
            "SYSTEM_BUSINESS_PASSIVE_LOGOUT" => Some(Self::SystemBusinessPassiveLogout),
            _ => None,
        }
    }
}
/// ===============================
/// äº‹ä»¶æšä¸¾
/// ===============================
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GroupEventType {
    GeUnspecified = 0,
    /// æˆå‘˜ç±»
    GeMemberJoined = 1,
    GeMemberLeft = 2,
    GeMemberKicked = 3,
    GeMemberInvited = 4,
    GeMemberApproved = 5,
    /// è§’è‰²ç±»
    GeRolePromoted = 10,
    GeRoleDemoted = 11,
    GeOwnerTransferred = 12,
    /// èµ„æ–™/è®¾ç½®ç±»
    GeInfoUpdated = 20,
    GePermsUpdated = 21,
    GeInviteLinkUpdated = 22,
    GeAnnouncementUpdated = 23,
    /// ç®¡æ§ç±»
    GeMuteOn = 30,
    GeMuteOff = 31,
    GeMemberMuted = 32,
    GeMemberUnmuted = 33,
    GeMemberBanned = 34,
    GeMemberUnbanned = 35,
    /// æ¶ˆæ¯ç®¡ç†
    GePinAdded = 40,
    GePinRemoved = 41,
    /// å…¶ä»–/æ‰©å±•
    GeCustom = 1000,
}
impl GroupEventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::GeUnspecified => "GE_UNSPECIFIED",
            Self::GeMemberJoined => "GE_MEMBER_JOINED",
            Self::GeMemberLeft => "GE_MEMBER_LEFT",
            Self::GeMemberKicked => "GE_MEMBER_KICKED",
            Self::GeMemberInvited => "GE_MEMBER_INVITED",
            Self::GeMemberApproved => "GE_MEMBER_APPROVED",
            Self::GeRolePromoted => "GE_ROLE_PROMOTED",
            Self::GeRoleDemoted => "GE_ROLE_DEMOTED",
            Self::GeOwnerTransferred => "GE_OWNER_TRANSFERRED",
            Self::GeInfoUpdated => "GE_INFO_UPDATED",
            Self::GePermsUpdated => "GE_PERMS_UPDATED",
            Self::GeInviteLinkUpdated => "GE_INVITE_LINK_UPDATED",
            Self::GeAnnouncementUpdated => "GE_ANNOUNCEMENT_UPDATED",
            Self::GeMuteOn => "GE_MUTE_ON",
            Self::GeMuteOff => "GE_MUTE_OFF",
            Self::GeMemberMuted => "GE_MEMBER_MUTED",
            Self::GeMemberUnmuted => "GE_MEMBER_UNMUTED",
            Self::GeMemberBanned => "GE_MEMBER_BANNED",
            Self::GeMemberUnbanned => "GE_MEMBER_UNBANNED",
            Self::GePinAdded => "GE_PIN_ADDED",
            Self::GePinRemoved => "GE_PIN_REMOVED",
            Self::GeCustom => "GE_CUSTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GE_UNSPECIFIED" => Some(Self::GeUnspecified),
            "GE_MEMBER_JOINED" => Some(Self::GeMemberJoined),
            "GE_MEMBER_LEFT" => Some(Self::GeMemberLeft),
            "GE_MEMBER_KICKED" => Some(Self::GeMemberKicked),
            "GE_MEMBER_INVITED" => Some(Self::GeMemberInvited),
            "GE_MEMBER_APPROVED" => Some(Self::GeMemberApproved),
            "GE_ROLE_PROMOTED" => Some(Self::GeRolePromoted),
            "GE_ROLE_DEMOTED" => Some(Self::GeRoleDemoted),
            "GE_OWNER_TRANSFERRED" => Some(Self::GeOwnerTransferred),
            "GE_INFO_UPDATED" => Some(Self::GeInfoUpdated),
            "GE_PERMS_UPDATED" => Some(Self::GePermsUpdated),
            "GE_INVITE_LINK_UPDATED" => Some(Self::GeInviteLinkUpdated),
            "GE_ANNOUNCEMENT_UPDATED" => Some(Self::GeAnnouncementUpdated),
            "GE_MUTE_ON" => Some(Self::GeMuteOn),
            "GE_MUTE_OFF" => Some(Self::GeMuteOff),
            "GE_MEMBER_MUTED" => Some(Self::GeMemberMuted),
            "GE_MEMBER_UNMUTED" => Some(Self::GeMemberUnmuted),
            "GE_MEMBER_BANNED" => Some(Self::GeMemberBanned),
            "GE_MEMBER_UNBANNED" => Some(Self::GeMemberUnbanned),
            "GE_PIN_ADDED" => Some(Self::GePinAdded),
            "GE_PIN_REMOVED" => Some(Self::GePinRemoved),
            "GE_CUSTOM" => Some(Self::GeCustom),
            _ => None,
        }
    }
}
/// æ¶ˆæ¯æ‰€å±å¤§ç±»ï¼šå¥½å‹ã€ç¾¤ã€ç³»ç»Ÿæˆ–æœªçŸ¥ã€‚
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MsgCategory {
    /// é»˜è®¤å€¼ï¼šæœªçŸ¥/æœªåˆ†ç±»æ¶ˆæ¯ã€‚
    Unknown = 0,
    /// å¥½å‹ç›¸å…³æ¶ˆæ¯ã€‚
    Friend = 1,
    /// ç¾¤èŠç›¸å…³æ¶ˆæ¯ã€‚
    Group = 2,
    /// ç³»ç»Ÿ/é€šç”¨é€šçŸ¥ã€‚
    System = 3,
}
impl MsgCategory {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "MSG_CATEGORY_UNKNOWN",
            Self::Friend => "MSG_CATEGORY_FRIEND",
            Self::Group => "MSG_CATEGORY_GROUP",
            Self::System => "MSG_CATEGORY_SYSTEM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MSG_CATEGORY_UNKNOWN" => Some(Self::Unknown),
            "MSG_CATEGORY_FRIEND" => Some(Self::Friend),
            "MSG_CATEGORY_GROUP" => Some(Self::Group),
            "MSG_CATEGORY_SYSTEM" => Some(Self::System),
            _ => None,
        }
    }
}
/// Reaction æ“ä½œ
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReactionAction {
    /// æœªæŒ‡å®šåŠ¨ä½œ
    RaUnknown = 0,
    RaAdd = 1,
    RaRemove = 2,
}
impl ReactionAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::RaUnknown => "RA_UNKNOWN",
            Self::RaAdd => "RA_ADD",
            Self::RaRemove => "RA_REMOVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RA_UNKNOWN" => Some(Self::RaUnknown),
            "RA_ADD" => Some(Self::RaAdd),
            "RA_REMOVE" => Some(Self::RaRemove),
            _ => None,
        }
    }
}
/// æ­£åœ¨è¾“å…¥çŠ¶æ€
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TypingState {
    TypingNone = 0,
    TypingText = 1,
    TypingVoice = 2,
    TypingUpload = 3,
}
impl TypingState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TypingNone => "TYPING_NONE",
            Self::TypingText => "TYPING_TEXT",
            Self::TypingVoice => "TYPING_VOICE",
            Self::TypingUpload => "TYPING_UPLOAD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TYPING_NONE" => Some(Self::TypingNone),
            "TYPING_TEXT" => Some(Self::TypingText),
            "TYPING_VOICE" => Some(Self::TypingVoice),
            "TYPING_UPLOAD" => Some(Self::TypingUpload),
            _ => None,
        }
    }
}
