// This file is @generated by prost-build.
/// 客户端握手请求：连接建立后首帧（现在置于 ClientMsg.auth）
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AuthMsg {
    /// 用户唯一 ID（由服务端体系分配）
    #[prost(int64, tag = "1")]
    pub uid: i64,
    /// 设备类型（枚举，复用 message.DeviceType）
    #[prost(enumeration = "crate::infra::grpc::message::DeviceType", tag = "2")]
    pub device_type: i32,
    /// 设备标识（业务自定义，如设备号、推送 token 等）
    #[prost(string, tag = "3")]
    pub device_id: ::prost::alloc::string::String,
    /// 鉴权令牌（JWT/opaque），用于绑定 user_id 校验
    #[prost(string, tag = "4")]
    pub token: ::prost::alloc::string::String,
    /// 客户端时间戳（毫秒），用于时钟漂移/重放保护
    #[prost(int64, tag = "5")]
    pub ts_ms: i64,
    /// 随机数，结合签名防重放
    #[prost(bytes = "vec", tag = "6")]
    pub nonce: ::prost::alloc::vec::Vec<u8>,
    /// 对关键字段的签名/HMAC（例如 HMAC(key, user_id|device_id|ts|nonce|token) ）
    #[prost(bytes = "vec", tag = "7")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// 是否尝试恢复会话（断线重连）
    #[prost(bool, tag = "8")]
    pub resume: bool,
    /// 客户端已确认的最后一条消息 ID（用于快速补发）
    #[prost(int64, tag = "9")]
    pub last_ack_id: i64,
    /// 能力协商：是否支持端到端加密（仅占位，不影响现有流程）
    #[prost(bool, tag = "10")]
    pub supports_encryption: bool,
    /// 支持的加密方案（如 "x25519+chacha20poly1305"）
    #[prost(string, repeated, tag = "11")]
    pub encryption_schemes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// 客户端上行消息（含 ACK）
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ClientMsg {
    /// 若存在，表示对服务端某条 id 的确认
    #[prost(int64, optional, tag = "1")]
    pub ack: ::core::option::Option<i64>,
    /// 鉴权载荷（首帧必须携带）
    #[prost(message, optional, tag = "2")]
    pub auth: ::core::option::Option<AuthMsg>,
    /// 心跳包标志位（仅用于保活，不携带业务 payload）
    #[prost(bool, optional, tag = "4")]
    pub heartbeat: ::core::option::Option<bool>,
    /// 业务负载（二进制，建议为 message.Content）
    #[prost(bytes = "vec", tag = "3")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
    /// 客户端上行幂等ID（用于去重/重试对账），不参与 ACK 语义
    #[prost(int64, optional, tag = "5")]
    pub client_id: ::core::option::Option<i64>,
}
/// 服务端下行消息（投递给客户端）
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ServerMsg {
    /// 消息唯一 ID（用于客户端 ACK 对齐）
    #[prost(int64, tag = "1")]
    pub id: i64,
    /// 鉴权结果（鉴权成功时返回，替代系统业务通知）
    #[prost(message, optional, tag = "2")]
    pub auth: ::core::option::Option<AuthMsg>,
    /// 二进制负载（建议为具体业务的 Protobuf，例如 message.Content）
    #[prost(bytes = "vec", tag = "3")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
    /// 业务时间戳（毫秒）
    #[prost(int64, tag = "4")]
    pub ts_ms: i64,
    /// 心跳包标志位（服务端下行保活，可不携带 payload）
    #[prost(bool, optional, tag = "5")]
    pub heartbeat: ::core::option::Option<bool>,
    /// 若存在，表示对客户端某条 id 的确认
    #[prost(int64, optional, tag = "6")]
    pub ack: ::core::option::Option<i64>,
}
