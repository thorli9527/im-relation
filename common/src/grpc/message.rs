// This file is @generated by prost-build.
/// ======================================
/// ğŸ’  æ¶ˆæ¯å†…å®¹ç»“æ„ï¼ˆoneof ç±»å‹ï¼‰
/// ======================================
/// ä½¿ç”¨ oneof å®šä¹‰ä¸åŒç±»å‹çš„æ¶ˆæ¯å†…å®¹ï¼Œç¡®ä¿æ¶ˆæ¯ç±»å‹çš„äº’æ–¥æ€§
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageContent {
    #[prost(
        oneof = "message_content::Content",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23"
    )]
    pub content: ::core::option::Option<message_content::Content>,
}
/// Nested message and enum types in `MessageContent`.
pub mod message_content {
    #[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Content {
        /// æ–‡æœ¬æ¶ˆæ¯ï¼šçº¯æ–‡æœ¬å†…å®¹
        #[prost(message, tag = "1")]
        Text(super::TextContent),
        /// å›¾ç‰‡æ¶ˆæ¯ï¼šå›¾ç‰‡æ–‡ä»¶
        #[prost(message, tag = "2")]
        Image(super::ImageContent),
        /// éŸ³é¢‘æ¶ˆæ¯ï¼šè¯­éŸ³æˆ–éŸ³ä¹
        #[prost(message, tag = "3")]
        Audio(super::AudioContent),
        /// è§†é¢‘æ¶ˆæ¯ï¼šè§†é¢‘æ–‡ä»¶
        #[prost(message, tag = "4")]
        Video(super::VideoContent),
        /// ä½ç½®æ¶ˆæ¯ï¼šåœ°ç†ä½ç½®ä¿¡æ¯
        #[prost(message, tag = "5")]
        Location(super::LocationContent),
        /// æ–‡ä»¶æ¶ˆæ¯ï¼šä»»æ„æ–‡ä»¶ç±»å‹
        #[prost(message, tag = "6")]
        File(super::FileContent),
        /// éŸ³è§†é¢‘é€šè¯ä¿¡ä»¤ï¼šé€šè¯æ§åˆ¶æ¶ˆæ¯
        #[prost(message, tag = "7")]
        AvCall(super::AvCallContent),
        /// è‡ªå®šä¹‰æ¶ˆæ¯ï¼šå¼€å‘è€…è‡ªå®šä¹‰ç»“æ„
        #[prost(message, tag = "8")]
        Custom(super::CustomContent),
        /// è¡¨æƒ…æ¶ˆæ¯ï¼šemoji è¡¨æƒ…
        #[prost(message, tag = "9")]
        Emoji(super::EmojiContent),
        /// æ’¤å›æ¶ˆæ¯ï¼šæ¶ˆæ¯æ’¤å›é€šçŸ¥
        #[prost(message, tag = "10")]
        Revoke(super::RevokeContent),
        /// è½¬å‘æ¶ˆæ¯ï¼šæ¶ˆæ¯è½¬å‘
        #[prost(message, tag = "11")]
        Forward(super::ForwardContent),
        /// å¼•ç”¨å›å¤æ¶ˆæ¯ï¼šå›å¤ç‰¹å®šæ¶ˆæ¯
        #[prost(message, tag = "12")]
        Quote(super::QuoteContent),
        /// HTML å¡ç‰‡ï¼šå¯Œæ–‡æœ¬å†…å®¹
        #[prost(message, tag = "13")]
        Html(super::HtmlContent),
        /// VOIP é€šè¯è®°å½•ï¼šé€šè¯æ—¥å¿—
        #[prost(message, tag = "14")]
        Voip(super::VoipContent),
        /// é€šçŸ¥æ¶ˆæ¯ï¼šç³»ç»Ÿé€šçŸ¥
        #[prost(message, tag = "15")]
        Notification(super::NotificationContent),
        /// ç³»ç»Ÿæ¶ˆæ¯ï¼šç³»ç»Ÿçº§æ¶ˆæ¯
        #[prost(message, tag = "16")]
        System(super::SystemContent),
        /// æé†’æ¶ˆæ¯ï¼šæé†’äº‹é¡¹
        #[prost(message, tag = "17")]
        Reminder(super::ReminderContent),
        /// ç¾¤ç»„äº‹ä»¶ï¼šç¾¤ç»„ç›¸å…³äº‹ä»¶
        #[prost(message, tag = "18")]
        GroupEvent(super::GroupEventContent),
        /// åç‰‡æ¶ˆæ¯ï¼šè”ç³»äººåˆ†äº«
        #[prost(message, tag = "19")]
        ContactCard(super::ContactCardContent),
        /// æŠ•ç¥¨æ¶ˆæ¯ï¼šæŠ•ç¥¨å†…å®¹
        #[prost(message, tag = "20")]
        Vote(super::VoteContent),
        /// çº¢åŒ…æ¶ˆæ¯ï¼šçº¢åŒ…å†…å®¹
        #[prost(message, tag = "21")]
        RedEnvelope(super::RedEnvelopeContent),
        /// åŠ å¯†å†…å®¹å°è£…ï¼ˆç«¯åˆ°ç«¯åŠ å¯†ï¼‰
        #[prost(message, tag = "22")]
        Encrypted(super::EncryptedContent),
        /// é€šç”¨ä¸šåŠ¡ç¡®è®¤/é€šçŸ¥ï¼ˆå¤„ç†ç»“æœå›æ‰§ï¼‰
        #[prost(message, tag = "23")]
        Ack(super::AckContent),
    }
}
/// ===============================
/// âœ… é€šç”¨ä¸šåŠ¡ç¡®è®¤/é€šçŸ¥ï¼ˆå¤„ç†ç»“æœå›æ‰§ï¼‰
/// ===============================
/// ç”¨äºæœåŠ¡ç«¯å‘å®¢æˆ·ç«¯å›ä¼ â€œè¯¥ä¸šåŠ¡å·²å¤„ç†â€çš„æ ‡å‡†ç»“æ„ã€‚
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AckContent {
    /// æ˜¯å¦æˆåŠŸ
    #[prost(bool, tag = "1")]
    pub ok: bool,
    /// ä¸šåŠ¡é”™è¯¯ç ï¼ˆ0 è¡¨ç¤ºæ— é”™è¯¯ï¼‰
    #[prost(int32, tag = "2")]
    pub code: i32,
    /// æ–‡æœ¬ä¿¡æ¯ï¼ˆå¯æœ¬åœ°åŒ–ï¼‰
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    /// è¯·æ±‚çš„ä¸šåŠ¡ç§ç±»ï¼ˆå¦‚ socket çš„ MsgKind å€¼ï¼‰
    #[prost(int32, tag = "4")]
    pub request_kind: i32,
    /// å¯é€‰çš„å¼•ç”¨æ¶ˆæ¯ IDï¼ˆä¸æ­¤æ¬¡å¤„ç†ç›¸å…³çš„æ¶ˆæ¯ï¼‰
    #[prost(uint64, optional, tag = "5")]
    pub ref_message_id: ::core::option::Option<u64>,
    /// é™„åŠ æ•°æ®ï¼ˆé¢„ç•™ï¼‰
    #[prost(bytes = "vec", tag = "6")]
    pub extra: ::prost::alloc::vec::Vec<u8>,
}
/// ===============================
/// ğŸ“„ æ–‡æœ¬æ¶ˆæ¯
/// ===============================
/// æ”¯æŒçº¯æ–‡æœ¬å’Œå¯Œæ–‡æœ¬æ ¼å¼ï¼ŒåŒ…å«å†…è”å®ä½“ï¼ˆé“¾æ¥ã€@ç”¨æˆ·ã€è¯é¢˜ç­‰ï¼‰
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextContent {
    /// æ–‡æœ¬ä¸»ä½“å†…å®¹ï¼šæ¶ˆæ¯çš„æ–‡æœ¬å†…å®¹
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    /// å¯Œæ–‡æœ¬å®ä½“ï¼Œå¦‚é“¾æ¥/@ç”¨æˆ·/è¯é¢˜ï¼šæ–‡æœ¬ä¸­çš„ç‰¹æ®Šå…ƒç´ 
    #[prost(message, repeated, tag = "2")]
    pub entities: ::prost::alloc::vec::Vec<InlineEntity>,
}
/// å†…è”å®ä½“ï¼šç”¨äºåœ¨æ–‡æœ¬ä¸­æ ‡è®°ç‰¹æ®Šå…ƒç´ 
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InlineEntity {
    /// èµ·å§‹ä½ç½®ï¼ˆUTF-8 å­—ç¬¦ç´¢å¼•ï¼‰ï¼šå®ä½“åœ¨æ–‡æœ¬ä¸­çš„å¼€å§‹ä½ç½®
    #[prost(int32, tag = "1")]
    pub start: i32,
    /// ç»“æŸä½ç½®ï¼ˆä¸å«ï¼‰ï¼šå®ä½“åœ¨æ–‡æœ¬ä¸­çš„ç»“æŸä½ç½®
    #[prost(int32, tag = "2")]
    pub end: i32,
    /// ç±»å‹ï¼šlink / mention / hashtagï¼šå®ä½“çš„ç±»å‹
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
    /// é™„åŠ å€¼ï¼šURLã€ç”¨æˆ·IDç­‰ï¼šå®ä½“çš„å…·ä½“å€¼
    #[prost(string, tag = "4")]
    pub value: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ–¼ï¸ å›¾ç‰‡æ¶ˆæ¯
/// ===============================
/// åŒ…å«å›¾ç‰‡çš„å®Œæ•´ä¿¡æ¯ï¼Œæ”¯æŒåŸå›¾å’Œç¼©ç•¥å›¾
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ImageContent {
    /// åŸå›¾ URLï¼šå›¾ç‰‡çš„å®Œæ•´åœ°å€
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    /// ç¼©ç•¥å›¾ URLï¼šå›¾ç‰‡çš„ç¼©ç•¥å›¾åœ°å€
    #[prost(string, tag = "2")]
    pub thumbnail_url: ::prost::alloc::string::String,
    /// å®½åº¦ï¼ˆåƒç´ ï¼‰ï¼šå›¾ç‰‡çš„å®½åº¦
    #[prost(int32, tag = "3")]
    pub width: i32,
    /// é«˜åº¦ï¼ˆåƒç´ ï¼‰ï¼šå›¾ç‰‡çš„é«˜åº¦
    #[prost(int32, tag = "4")]
    pub height: i32,
    /// æ ¼å¼ï¼ˆå¦‚ jpg/pngï¼‰ï¼šå›¾ç‰‡çš„æ–‡ä»¶æ ¼å¼
    #[prost(string, tag = "5")]
    pub format: ::prost::alloc::string::String,
    /// æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰ï¼šå›¾ç‰‡æ–‡ä»¶çš„å¤§å°
    #[prost(int64, tag = "6")]
    pub size: i64,
}
/// ===============================
/// ğŸ”Š éŸ³é¢‘æ¶ˆæ¯
/// ===============================
/// æ”¯æŒè¯­éŸ³èŠå¤©å’ŒéŸ³ä¹æ’­æ”¾ï¼ŒåŒ…å«æ—¶é•¿å’Œæ ¼å¼ä¿¡æ¯
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AudioContent {
    /// éŸ³é¢‘æ–‡ä»¶ URLï¼šéŸ³é¢‘æ–‡ä»¶çš„åœ°å€
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    /// æ—¶é•¿ï¼ˆç§’ï¼‰ï¼šéŸ³é¢‘çš„æ’­æ”¾æ—¶é•¿
    #[prost(int32, tag = "2")]
    pub duration: i32,
    /// æ ¼å¼ï¼šéŸ³é¢‘æ–‡ä»¶æ ¼å¼ï¼ˆå¦‚ mp3/wavï¼‰
    #[prost(string, tag = "3")]
    pub format: ::prost::alloc::string::String,
    /// æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰ï¼šéŸ³é¢‘æ–‡ä»¶çš„å¤§å°
    #[prost(int64, tag = "4")]
    pub size: i64,
    /// æ˜¯å¦è¯­éŸ³ï¼ˆvs éŸ³ä¹ç±»éŸ³é¢‘ï¼‰ï¼štrueè¡¨ç¤ºè¯­éŸ³ï¼Œfalseè¡¨ç¤ºéŸ³ä¹
    #[prost(bool, tag = "5")]
    pub is_voice: bool,
}
/// ===============================
/// ğŸï¸ è§†é¢‘æ¶ˆæ¯
/// ===============================
/// åŒ…å«è§†é¢‘æ–‡ä»¶å’Œå°é¢å›¾ï¼Œæ”¯æŒæ’­æ”¾æ§åˆ¶
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VideoContent {
    /// è§†é¢‘æ–‡ä»¶ URLï¼šè§†é¢‘æ–‡ä»¶çš„åœ°å€
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    /// æ—¶é•¿ï¼ˆç§’ï¼‰ï¼šè§†é¢‘çš„æ’­æ”¾æ—¶é•¿
    #[prost(int32, tag = "2")]
    pub duration: i32,
    /// å°é¢å›¾ URLï¼šè§†é¢‘çš„å°é¢å›¾ç‰‡
    #[prost(string, tag = "3")]
    pub cover_url: ::prost::alloc::string::String,
    /// å®½åº¦ï¼ˆåƒç´ ï¼‰ï¼šè§†é¢‘çš„å®½åº¦
    #[prost(int32, tag = "4")]
    pub width: i32,
    /// é«˜åº¦ï¼ˆåƒç´ ï¼‰ï¼šè§†é¢‘çš„é«˜åº¦
    #[prost(int32, tag = "5")]
    pub height: i32,
    /// æ ¼å¼ï¼šè§†é¢‘æ–‡ä»¶æ ¼å¼ï¼ˆå¦‚ mp4/aviï¼‰
    #[prost(string, tag = "6")]
    pub format: ::prost::alloc::string::String,
    /// æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰ï¼šè§†é¢‘æ–‡ä»¶çš„å¤§å°
    #[prost(int64, tag = "7")]
    pub size: i64,
}
/// ===============================
/// ğŸ“ ä½ç½®æ¶ˆæ¯
/// ===============================
/// åŒ…å«åœ°ç†ä½ç½®ä¿¡æ¯ï¼Œæ”¯æŒåœ°å€æè¿°å’Œåœ°å›¾æ˜¾ç¤º
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocationContent {
    /// çº¬åº¦ï¼šåœ°ç†ä½ç½®çš„çº¬åº¦åæ ‡
    #[prost(double, tag = "1")]
    pub latitude: f64,
    /// ç»åº¦ï¼šåœ°ç†ä½ç½®çš„ç»åº¦åæ ‡
    #[prost(double, tag = "2")]
    pub longitude: f64,
    /// åœ°å€æè¿°ï¼šä½ç½®çš„æ–‡å­—æè¿°
    #[prost(string, tag = "3")]
    pub address: ::prost::alloc::string::String,
    /// åœ°ç‚¹åç§°ï¼šå…·ä½“çš„åœ°ç‚¹åç§°
    #[prost(string, tag = "4")]
    pub poi_name: ::prost::alloc::string::String,
    /// ç¼©ç•¥å›¾ URLï¼šä½ç½®çš„åœ°å›¾ç¼©ç•¥å›¾
    #[prost(string, tag = "5")]
    pub thumbnail_url: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ“ æ–‡ä»¶æ¶ˆæ¯
/// ===============================
/// æ”¯æŒä»»æ„æ–‡ä»¶ç±»å‹ï¼ŒåŒ…å«æ–‡ä»¶ä¿¡æ¯å’Œå›¾æ ‡
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FileContent {
    /// æ–‡ä»¶ URLï¼šæ–‡ä»¶çš„ä¸‹è½½åœ°å€
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    /// æ–‡ä»¶åï¼šæ–‡ä»¶çš„æ˜¾ç¤ºåç§°
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰ï¼šæ–‡ä»¶çš„å¤§å°
    #[prost(int64, tag = "3")]
    pub size: i64,
    /// æ–‡ä»¶ç±»å‹ï¼šæ–‡ä»¶çš„ MIME ç±»å‹
    #[prost(string, tag = "4")]
    pub file_type: ::prost::alloc::string::String,
    /// å›¾æ ‡ URLï¼šæ–‡ä»¶ç±»å‹çš„å›¾æ ‡
    #[prost(string, tag = "5")]
    pub icon_url: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ“ éŸ³è§†é¢‘é€šè¯ä¿¡ä»¤
/// ===============================
/// ç”¨äºéŸ³è§†é¢‘é€šè¯çš„æ§åˆ¶ä¿¡ä»¤ï¼ŒåŒ…å«é€šè¯çŠ¶æ€å’Œå‚ä¸è€…ä¿¡æ¯
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AvCallContent {
    /// é€šè¯ IDï¼šé€šè¯çš„å”¯ä¸€æ ‡è¯†
    #[prost(string, tag = "1")]
    pub call_id: ::prost::alloc::string::String,
    /// å‘èµ·è€… IDï¼šé€šè¯çš„å‘èµ·ç”¨æˆ·
    #[prost(int64, tag = "2")]
    pub initiator_uid: i64,
    /// å‚ä¸è€… ID åˆ—è¡¨ï¼šé€šè¯çš„æ‰€æœ‰å‚ä¸è€…
    #[prost(int64, repeated, tag = "3")]
    pub participant_ids: ::prost::alloc::vec::Vec<i64>,
    /// é€šè¯æ“ä½œï¼šå…·ä½“çš„é€šè¯åŠ¨ä½œ
    #[prost(enumeration = "av_call_content::CallAction", tag = "4")]
    pub action: i32,
    /// é€šè¯ç±»å‹ï¼šé€šè¯çš„ç±»å‹
    #[prost(enumeration = "av_call_content::CallType", tag = "5")]
    pub r#type: i32,
    /// æ—¶é—´æˆ³ï¼šæ“ä½œçš„æ—¶é—´
    #[prost(int64, tag = "6")]
    pub timestamp: i64,
    /// æ—¶é•¿ï¼ˆç§’ï¼‰ï¼šé€šè¯çš„æŒç»­æ—¶é—´
    #[prost(int32, tag = "7")]
    pub duration: i32,
}
/// Nested message and enum types in `AVCallContent`.
pub mod av_call_content {
    #[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum CallAction {
        /// æœªçŸ¥æ“ä½œ
        Unknown = 0,
        /// é‚€è¯·ï¼šå‘èµ·é€šè¯é‚€è¯·
        Invite = 1,
        /// æ¥å—ï¼šæ¥å—é€šè¯é‚€è¯·
        Accept = 2,
        /// æ‹’ç»ï¼šæ‹’ç»é€šè¯é‚€è¯·
        Reject = 3,
        /// å–æ¶ˆï¼šå–æ¶ˆé€šè¯
        Cancel = 4,
        /// ç»“æŸï¼šç»“æŸé€šè¯
        End = 5,
        /// è¶…æ—¶ï¼šé€šè¯è¶…æ—¶
        Timeout = 6,
    }
    impl CallAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Invite => "INVITE",
                Self::Accept => "ACCEPT",
                Self::Reject => "REJECT",
                Self::Cancel => "CANCEL",
                Self::End => "END",
                Self::Timeout => "TIMEOUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "INVITE" => Some(Self::Invite),
                "ACCEPT" => Some(Self::Accept),
                "REJECT" => Some(Self::Reject),
                "CANCEL" => Some(Self::Cancel),
                "END" => Some(Self::End),
                "TIMEOUT" => Some(Self::Timeout),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum CallType {
        /// éŸ³é¢‘é€šè¯ï¼šä»…è¯­éŸ³é€šè¯
        Audio = 0,
        /// è§†é¢‘é€šè¯ï¼šéŸ³è§†é¢‘é€šè¯
        Video = 1,
    }
    impl CallType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Audio => "AUDIO",
                Self::Video => "VIDEO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AUDIO" => Some(Self::Audio),
                "VIDEO" => Some(Self::Video),
                _ => None,
            }
        }
    }
}
/// ===============================
/// ğŸ’  è‡ªå®šä¹‰ç»“æ„åŒ–æ¶ˆæ¯
/// ===============================
/// æ”¯æŒå¼€å‘è€…è‡ªå®šä¹‰çš„æ¶ˆæ¯ç»“æ„ï¼Œé€šå¸¸ä»¥ JSON æ ¼å¼æ‰¿è½½
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CustomContent {
    /// è‡ªå®šä¹‰ç±»å‹ï¼šæ¶ˆæ¯çš„è‡ªå®šä¹‰ç±»å‹æ ‡è¯†
    #[prost(string, tag = "1")]
    pub custom_type: ::prost::alloc::string::String,
    /// JSON è½½è·ï¼šè‡ªå®šä¹‰æ¶ˆæ¯çš„ JSON æ•°æ®
    #[prost(string, tag = "2")]
    pub json_payload: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ˜„ è¡¨æƒ…æ¶ˆæ¯
/// ===============================
/// æ”¯æŒæ ‡å‡† emoji å’Œè‡ªå®šä¹‰è¡¨æƒ…
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EmojiContent {
    /// è¡¨æƒ…ç±»å‹ï¼šæ ‡å‡† emoji ç±»å‹
    #[prost(enumeration = "EmojiType", tag = "1")]
    pub emoji: i32,
    /// è‡ªå®šä¹‰è¡¨æƒ… URLï¼šè‡ªå®šä¹‰è¡¨æƒ…çš„å›¾ç‰‡åœ°å€
    #[prost(string, tag = "2")]
    pub custom_emoji_url: ::prost::alloc::string::String,
}
/// ===============================
/// â›” æ’¤å›æ¶ˆæ¯
/// ===============================
/// ç”¨äºé€šçŸ¥æ¶ˆæ¯æ’¤å›ï¼ŒåŒ…å«æ’¤å›çš„ç›®æ ‡æ¶ˆæ¯ä¿¡æ¯
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RevokeContent {
    /// ç›®æ ‡æ¶ˆæ¯ IDï¼šè¢«æ’¤å›çš„æ¶ˆæ¯ID
    #[prost(int64, tag = "1")]
    pub target_message_id: i64,
    /// æ“ä½œè€… IDï¼šæ‰§è¡Œæ’¤å›æ“ä½œçš„ç”¨æˆ·
    #[prost(int64, tag = "2")]
    pub operator_id: i64,
    /// æ’¤å›æ—¶é—´ï¼šæ’¤å›æ“ä½œçš„æ—¶é—´æˆ³
    #[prost(int64, tag = "3")]
    pub revoke_time: i64,
}
/// ===============================
/// ğŸ“¤ è½¬å‘æ¶ˆæ¯
/// ===============================
/// ç”¨äºæ¶ˆæ¯è½¬å‘ï¼ŒåŒ…å«åŸæ¶ˆæ¯çš„åŸºæœ¬ä¿¡æ¯
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ForwardContent {
    /// åŸæ¶ˆæ¯ IDï¼šè¢«è½¬å‘æ¶ˆæ¯çš„ID
    #[prost(uint64, tag = "1")]
    pub original_message_id: u64,
    /// åŸå‘é€è€… IDï¼šåŸæ¶ˆæ¯çš„å‘é€è€…
    #[prost(string, tag = "2")]
    pub original_sender_id: ::prost::alloc::string::String,
    /// åŸæ¶ˆæ¯ç±»å‹ï¼šåŸæ¶ˆæ¯çš„ç±»å‹
    #[prost(enumeration = "ContentType", tag = "3")]
    pub original_type: i32,
    /// æ‘˜è¦ï¼šè½¬å‘çš„æ‘˜è¦ä¿¡æ¯
    #[prost(string, tag = "4")]
    pub summary: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ“Œ å¼•ç”¨å›å¤æ¶ˆæ¯
/// ===============================
/// ç”¨äºå›å¤ç‰¹å®šæ¶ˆæ¯ï¼ŒåŒ…å«è¢«å¼•ç”¨æ¶ˆæ¯çš„ä¿¡æ¯
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QuoteContent {
    /// è¢«å¼•ç”¨æ¶ˆæ¯ IDï¼šè¢«å›å¤æ¶ˆæ¯çš„ID
    #[prost(uint64, tag = "1")]
    pub quoted_message_id: u64,
    /// è¢«å¼•ç”¨å†…å®¹é¢„è§ˆï¼šè¢«å›å¤æ¶ˆæ¯çš„é¢„è§ˆ
    #[prost(string, tag = "2")]
    pub quoted_content_preview: ::prost::alloc::string::String,
    /// å¼•ç”¨æ–‡æœ¬ï¼šå›å¤çš„æ–‡æœ¬å†…å®¹
    #[prost(string, tag = "3")]
    pub quote_text: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸŒ HTML å¡ç‰‡
/// ===============================
/// ç”¨äºå¯Œæ–‡æœ¬å†…å®¹ï¼Œæ”¯æŒç½‘é¡µé“¾æ¥å’Œé¢„è§ˆ
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HtmlContent {
    /// æ ‡é¢˜ï¼šå¡ç‰‡çš„æ ‡é¢˜
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    /// URLï¼šé“¾æ¥åœ°å€
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    /// é¢„è§ˆï¼šå†…å®¹çš„é¢„è§ˆæ–‡æœ¬
    #[prost(string, tag = "3")]
    pub preview: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ“ VOIP é€šè¯è®°å½•
/// ===============================
/// ç”¨äºè®°å½•é€šè¯å†å²ï¼ŒåŒ…å«é€šè¯çš„åŸºæœ¬ä¿¡æ¯
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VoipContent {
    /// ä¸»å« IDï¼šå‘èµ·é€šè¯çš„ç”¨æˆ·
    #[prost(string, tag = "1")]
    pub caller_id: ::prost::alloc::string::String,
    /// è¢«å« IDï¼šæ¥æ”¶é€šè¯çš„ç”¨æˆ·
    #[prost(string, tag = "2")]
    pub callee_id: ::prost::alloc::string::String,
    /// é€šè¯æ—¶é•¿ï¼ˆç§’ï¼‰ï¼šé€šè¯çš„æŒç»­æ—¶é—´
    #[prost(int64, tag = "3")]
    pub duration: i64,
    /// é€šè¯çŠ¶æ€ï¼šé€šè¯çš„ç»“æœçŠ¶æ€
    #[prost(string, tag = "4")]
    pub status: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ”” é€šçŸ¥æ¶ˆæ¯
/// ===============================
/// ç”¨äºç³»ç»Ÿé€šçŸ¥ï¼ŒåŒ…å«æ ‡é¢˜ã€å†…å®¹å’Œå…ƒæ•°æ®
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotificationContent {
    /// æ ‡é¢˜ï¼šé€šçŸ¥çš„æ ‡é¢˜
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    /// å†…å®¹ï¼šé€šçŸ¥çš„ä¸»ä½“å†…å®¹
    #[prost(string, tag = "2")]
    pub body: ::prost::alloc::string::String,
    /// å…ƒæ•°æ®ï¼šé€šçŸ¥çš„é™„åŠ ä¿¡æ¯
    #[prost(map = "string, string", tag = "3")]
    pub metadata:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// ===============================
/// âš™ï¸ ç³»ç»Ÿæ¶ˆæ¯
/// ===============================
/// ç”¨äºç³»ç»Ÿçº§æ¶ˆæ¯ï¼ŒåŒ…å«ç³»ç»Ÿä»£ç å’Œå†…å®¹
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SystemContent {
    /// å†…å®¹ï¼šç³»ç»Ÿæ¶ˆæ¯çš„å†…å®¹
    #[prost(string, tag = "1")]
    pub content: ::prost::alloc::string::String,
    /// ä»£ç ï¼šç³»ç»Ÿæ¶ˆæ¯çš„ä»£ç æ ‡è¯†
    #[prost(string, tag = "2")]
    pub code: ::prost::alloc::string::String,
}
/// ===============================
/// â° æé†’äº‹é¡¹
/// ===============================
/// ç”¨äºæé†’åŠŸèƒ½ï¼ŒåŒ…å«æé†’æ–‡æœ¬å’Œæ—¶é—´
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReminderContent {
    /// æ–‡æœ¬ï¼šæé†’çš„å†…å®¹
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    /// æé†’æ—¶é—´ï¼šæé†’è§¦å‘çš„æ—¶é—´æˆ³
    #[prost(int64, tag = "2")]
    pub remind_at: i64,
}
/// ===============================
/// ğŸ‘¥ ç¾¤ç»„äº‹ä»¶
/// ===============================
/// ç”¨äºç¾¤ç»„ç›¸å…³äº‹ä»¶ï¼ŒåŒ…å«ç¾¤ç»„ä¿¡æ¯å’Œæ“ä½œè€…
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GroupEventContent {
    /// ç¾¤ç»„ IDï¼šäº‹ä»¶ç›¸å…³çš„ç¾¤ç»„
    #[prost(int64, tag = "1")]
    pub group_id: i64,
    /// äº‹ä»¶ï¼šäº‹ä»¶çš„å…·ä½“æè¿°
    #[prost(string, tag = "2")]
    pub event: ::prost::alloc::string::String,
    /// æ“ä½œè€… IDï¼šæ‰§è¡Œæ“ä½œçš„ç”¨æˆ·
    #[prost(int64, tag = "3")]
    pub operator_id: i64,
}
/// ===============================
/// ğŸ“‡ åç‰‡æ¶ˆæ¯
/// ===============================
/// ç”¨äºåˆ†äº«è”ç³»äººä¿¡æ¯ï¼ŒåŒ…å«ç”¨æˆ·çš„åŸºæœ¬ä¿¡æ¯
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ContactCardContent {
    /// ç›®æ ‡ IDï¼šè¢«åˆ†äº«ç”¨æˆ·çš„ID
    #[prost(string, tag = "1")]
    pub target_id: ::prost::alloc::string::String,
    /// æ˜¾ç¤ºåç§°ï¼šç”¨æˆ·çš„æ˜¾ç¤ºåç§°
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// å¤´åƒ URLï¼šç”¨æˆ·çš„å¤´åƒåœ°å€
    #[prost(string, tag = "3")]
    pub avatar_url: ::prost::alloc::string::String,
    /// å¡ç‰‡ç±»å‹ï¼šåç‰‡çš„ç±»å‹ï¼ˆç”¨æˆ·/ç¾¤ç»„ï¼‰
    #[prost(string, tag = "4")]
    pub card_type: ::prost::alloc::string::String,
}
/// ===============================
/// ğŸ“Š æŠ•ç¥¨æ¶ˆæ¯
/// ===============================
/// ç”¨äºç¾¤ç»„æŠ•ç¥¨åŠŸèƒ½ï¼ŒåŒ…å«æŠ•ç¥¨é€‰é¡¹å’Œç»“æœ
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VoteContent {
    /// ä¸»é¢˜ï¼šæŠ•ç¥¨çš„ä¸»é¢˜
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    /// é€‰é¡¹ï¼šæŠ•ç¥¨çš„é€‰é¡¹åˆ—è¡¨
    #[prost(string, repeated, tag = "2")]
    pub options: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// ç»“æœï¼šæŠ•ç¥¨ç»“æœç»Ÿè®¡
    #[prost(map = "string, int32", tag = "3")]
    pub result: ::std::collections::HashMap<::prost::alloc::string::String, i32>,
    /// å¤šé€‰ï¼šæ˜¯å¦å…è®¸å¤šé€‰
    #[prost(bool, tag = "4")]
    pub multi_choice: bool,
}
/// ===============================
/// ğŸ’° çº¢åŒ…æ¶ˆæ¯
/// ===============================
/// ç”¨äºçº¢åŒ…åŠŸèƒ½ï¼ŒåŒ…å«çº¢åŒ…é‡‘é¢å’ŒçŠ¶æ€
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RedEnvelopeContent {
    /// å‘é€è€… IDï¼šçº¢åŒ…å‘é€è€…
    #[prost(int64, tag = "1")]
    pub sender_id: i64,
    /// é‡‘é¢ï¼šçº¢åŒ…é‡‘é¢ï¼ˆåˆ†ï¼‰
    #[prost(int32, tag = "2")]
    pub amount: i32,
    /// ç¥ç¦è¯­ï¼šçº¢åŒ…çš„ç¥ç¦è¯­
    #[prost(string, tag = "3")]
    pub blessing: ::prost::alloc::string::String,
    /// æ˜¯å¦å·²é¢†å–ï¼šçº¢åŒ…æ˜¯å¦å·²è¢«é¢†å–
    #[prost(bool, tag = "4")]
    pub claimed: bool,
}
/// ======================================
/// âœ‚ï¸ Segment - æ¶ˆæ¯æ®µç»“æ„ï¼ˆç”¨äºå¤åˆå†…å®¹ï¼‰
/// ======================================
/// è¡¨ç¤ºä¸€æ¡æ¶ˆæ¯ä¸­çš„ä¸€ä¸ªç‹¬ç«‹æ®µï¼ˆå¦‚æ–‡æœ¬æ®µã€å›¾ç‰‡æ®µç­‰ï¼‰ï¼Œæ”¯æŒæ’åºã€ç¼–è¾‘ã€æ ‡è®°ç­‰
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Segment {
    /// æ¶ˆæ¯æ®µå†…å®¹ï¼ˆå¦‚æ–‡æœ¬ã€å›¾ç‰‡ç­‰ï¼Œä½¿ç”¨ oneof å°è£…ï¼‰ï¼šæ®µçš„å…·ä½“å†…å®¹
    #[prost(message, optional, tag = "1")]
    pub body: ::core::option::Option<MessageContent>,
    /// æ¶ˆæ¯å†…é¡ºåºç¼–å·ï¼ˆç”¨äºå‰ç«¯æ¸²æŸ“æ’åºï¼‰ï¼šæ®µåœ¨æ¶ˆæ¯ä¸­çš„é¡ºåº
    #[prost(uint64, tag = "2")]
    pub seq_in_msg: u64,
    /// é€šç”¨æ‰©å±•å­—æ®µï¼ˆä»¥å­—ç¬¦ä¸²é”®å€¼å¯¹å­˜å‚¨ JSON æ‰å¹³æ•°æ®ï¼‰ï¼šæ®µçš„å…ƒæ•°æ®
    #[prost(map = "string, string", tag = "3")]
    pub metadata:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// ======================================
/// ğŸ“¨ é¡¶å±‚æ¶ˆæ¯ç»“æ„
/// ======================================
/// å®šä¹‰äº†æ¶ˆæ¯çš„åŸºæœ¬æ¡†æ¶ï¼ŒåŒ…å«å‘é€è€…ã€æ¥æ”¶è€…ã€æ—¶é—´ç­‰å…ƒæ•°æ®
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Content {
    /// å”¯ä¸€æ¶ˆæ¯ IDï¼ˆå®¢æˆ·ç«¯ç”Ÿæˆæˆ–æœåŠ¡ç«¯è¡¥å…¨ï¼‰ï¼šæ¶ˆæ¯çš„å”¯ä¸€æ ‡è¯†
    #[prost(uint64, optional, tag = "1")]
    pub message_id: ::core::option::Option<u64>,
    /// æ¶ˆæ¯å‘é€æ–¹ï¼šå‘é€æ¶ˆæ¯çš„ç”¨æˆ·ID
    #[prost(int64, tag = "2")]
    pub sender_id: i64,
    /// æ¶ˆæ¯æ¥æ”¶æ–¹ï¼ˆå•èŠä¸ºå¯¹æ–¹ IDï¼Œç¾¤èŠä¸ºç¾¤ IDï¼‰ï¼šæ¥æ”¶æ¶ˆæ¯çš„ç›®æ ‡
    #[prost(int64, tag = "3")]
    pub receiver_id: i64,
    /// æ¶ˆæ¯å‘é€æ—¶é—´ï¼ˆæ¯«ç§’æ—¶é—´æˆ³ï¼‰ï¼šæ¶ˆæ¯åˆ›å»ºçš„æ—¶é—´
    #[prost(int64, tag = "4")]
    pub timestamp: i64,
    /// ä¸»æ¶ˆæ¯ç±»å‹ï¼ˆç”¨äºå¿«é€Ÿæ¸²æŸ“åˆ¤æ–­ï¼‰ï¼šæ¶ˆæ¯çš„ä¸»è¦ç±»å‹
    #[prost(enumeration = "ContentType", tag = "5")]
    pub message_type: i32,
    /// æ¶ˆæ¯æ‰€å±ä¼šè¯ç±»å‹ï¼ˆå•èŠ/ç¾¤èŠï¼‰ï¼šæ¶ˆæ¯çš„ä¼šè¯åœºæ™¯
    #[prost(enumeration = "ChatScene", tag = "6")]
    pub scene: i32,
    /// å¤šæ®µå¤åˆå†…å®¹ï¼ˆå¦‚æ–‡æœ¬ + å›¾ç‰‡ï¼‰ï¼šæ¶ˆæ¯çš„å…·ä½“å†…å®¹
    #[prost(message, repeated, tag = "10")]
    pub contents: ::prost::alloc::vec::Vec<MessageContent>,
}
/// å‘èµ·å‘¼å«ï¼ˆå¸¦ SDP offerï¼‰
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CallInvite {
    /// é€šè¯IDï¼ˆå…¨å±€å”¯ä¸€å­—ç¬¦ä¸²/é›ªèŠ±ï¼‰
    #[prost(string, tag = "1")]
    pub call_id: ::prost::alloc::string::String,
    /// ä¸»å«ç”¨æˆ·ID
    #[prost(int64, tag = "2")]
    pub from_user_id: i64,
    /// è¢«å«ç”¨æˆ·ID
    #[prost(int64, tag = "3")]
    pub to_user_id: i64,
    /// åª’ä½“ç±»å‹ï¼ˆè¯­éŸ³/è§†é¢‘ï¼‰
    #[prost(enumeration = "CallMediaType", tag = "4")]
    pub media_type: i32,
    /// SDP offerï¼ˆè‹¥ä½¿ç”¨ WebRTCï¼‰
    #[prost(string, tag = "5")]
    pub sdp_offer: ::prost::alloc::string::String,
    /// æ‰©å±•å­—æ®µ
    #[prost(string, optional, tag = "6")]
    pub ext: ::core::option::Option<::prost::alloc::string::String>,
    /// å‘èµ·æ—¶é—´
    #[prost(uint64, tag = "7")]
    pub created_at: u64,
}
/// å–æ¶ˆå‘¼å«ï¼ˆæŒ¯é“ƒé˜¶æ®µï¼‰
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CallCancel {
    /// é€šè¯ID
    #[prost(string, tag = "1")]
    pub call_id: ::prost::alloc::string::String,
    /// æ“ä½œè€…
    #[prost(int64, tag = "2")]
    pub operator_user_id: i64,
    /// åŸå› ï¼ˆå¯é€‰ï¼‰
    #[prost(string, optional, tag = "3")]
    pub reason: ::core::option::Option<::prost::alloc::string::String>,
    /// æ—¶é—´
    #[prost(uint64, tag = "4")]
    pub at: u64,
}
/// æ‹’ç»å‘¼å«
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CallReject {
    /// é€šè¯ID
    #[prost(string, tag = "1")]
    pub call_id: ::prost::alloc::string::String,
    /// æ‹’ç»è€…
    #[prost(int64, tag = "2")]
    pub reject_user_id: i64,
    /// åŸå› ï¼ˆå¯é€‰ï¼‰
    #[prost(string, optional, tag = "3")]
    pub reason: ::core::option::Option<::prost::alloc::string::String>,
    /// æ—¶é—´
    #[prost(uint64, tag = "4")]
    pub at: u64,
}
/// æ¥å—å‘¼å«ï¼ˆå¸¦ SDP answerï¼‰
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CallAccept {
    /// é€šè¯ID
    #[prost(string, tag = "1")]
    pub call_id: ::prost::alloc::string::String,
    /// æ¥å—è€…
    #[prost(int64, tag = "2")]
    pub accept_user_id: i64,
    /// SDP answerï¼ˆè‹¥ä½¿ç”¨ WebRTCï¼‰
    #[prost(string, tag = "3")]
    pub sdp_answer: ::prost::alloc::string::String,
    /// æ—¶é—´
    #[prost(uint64, tag = "4")]
    pub at: u64,
}
/// é€šè¯ç»“æŸ/æŒ‚æ–­
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CallHangup {
    /// é€šè¯ID
    #[prost(string, tag = "1")]
    pub call_id: ::prost::alloc::string::String,
    /// æ“ä½œè€…
    #[prost(int64, tag = "2")]
    pub operator_user_id: i64,
    /// ç»“æŸåŸå› 
    #[prost(enumeration = "CallEndReason", tag = "3")]
    pub reason: i32,
    /// é€šè¯æ—¶é•¿ï¼ˆæ¯«ç§’ï¼Œå¯é€‰ï¼‰
    #[prost(uint64, optional, tag = "4")]
    pub duration_ms: ::core::option::Option<u64>,
    /// æ—¶é—´
    #[prost(uint64, tag = "5")]
    pub at: u64,
}
/// é€šè¯ä¸­ä¿®æ”¹ï¼ˆé™éŸ³/å¼€å…³æ‘„åƒå¤´ç­‰ï¼‰
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CallModify {
    /// é€šè¯ID
    #[prost(string, tag = "1")]
    pub call_id: ::prost::alloc::string::String,
    /// æ“ä½œè€…
    #[prost(int64, tag = "2")]
    pub operator_user_id: i64,
    /// ä¿®æ”¹ç±»å‹
    #[prost(enumeration = "CallModifyType", tag = "3")]
    pub modify: i32,
    /// å¼€å…³å€¼ï¼ˆtrue=å¼€/å¯ç”¨ï¼Œfalse=å…³/ç¦ç”¨ï¼‰
    #[prost(bool, tag = "4")]
    pub on: bool,
    /// æ—¶é—´
    #[prost(uint64, tag = "5")]
    pub at: u64,
}
/// DTMF ä¿¡ä»¤
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CallDtmf {
    /// é€šè¯ID
    #[prost(string, tag = "1")]
    pub call_id: ::prost::alloc::string::String,
    /// å‘é€è€…
    #[prost(int64, tag = "2")]
    pub from_user_id: i64,
    /// DTMF æŒ‰é”®åºåˆ—ï¼ˆå¦‚ "123#*")
    #[prost(string, tag = "3")]
    pub digits: ::prost::alloc::string::String,
    /// æ—¶é—´
    #[prost(uint64, tag = "4")]
    pub at: u64,
}
/// é€è¾¾å›æ‰§ç¡®è®¤ï¼ˆå®¢æˆ·ç«¯â†’æœåŠ¡ç«¯ï¼šæ”¶åˆ° deliveredï¼‰
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MsgDeliveredAck {
    #[prost(int64, tag = "1")]
    pub msg_id: i64,
    #[prost(int64, tag = "2")]
    pub ack_user_id: i64,
    #[prost(int64, tag = "3")]
    pub ack_at: i64,
}
/// å·²è¯»ä¸ŠæŠ¥ï¼ˆå®¢æˆ·ç«¯â†’æœåŠ¡ç«¯ï¼‰
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MsgRead {
    #[prost(int64, tag = "1")]
    pub msg_id: i64,
    #[prost(int64, tag = "2")]
    pub user_id: i64,
    /// å•èŠï¼šå¯¹æ–¹IDï¼›ç¾¤èŠï¼šç¾¤ID
    #[prost(int64, tag = "3")]
    pub chat_id: i64,
    #[prost(int64, tag = "4")]
    pub read_at: i64,
}
/// å·²è¯»å›æ‰§ç¡®è®¤ï¼ˆæœåŠ¡ç«¯â†’å®¢æˆ·ç«¯ï¼šæ”¶åˆ° readï¼‰
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MsgReadAck {
    #[prost(int64, tag = "1")]
    pub msg_id: i64,
    #[prost(int64, tag = "2")]
    pub ack_user_id: i64,
    #[prost(int64, tag = "3")]
    pub ack_at: i64,
}
/// æ¶ˆæ¯æ’¤å›
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MsgRecall {
    #[prost(int64, tag = "1")]
    pub msg_id: i64,
    #[prost(int64, tag = "2")]
    pub operator_user_id: i64,
    #[prost(string, optional, tag = "3")]
    pub reason: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, tag = "4")]
    pub recalled_at: i64,
}
/// æ¶ˆæ¯è½¬å‘
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MsgForward {
    #[prost(int64, tag = "1")]
    pub src_msg_id: i64,
    #[prost(int64, optional, tag = "2")]
    pub new_msg_id: ::core::option::Option<i64>,
    #[prost(int64, tag = "3")]
    pub from_user_id: i64,
    #[prost(int64, tag = "4")]
    pub to_user_id: i64,
    #[prost(int64, tag = "5")]
    pub created_at: i64,
}
/// æ¶ˆæ¯è¡¨æ€ï¼ˆemoji/reactionï¼‰
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MsgReaction {
    #[prost(int64, tag = "1")]
    pub msg_id: i64,
    #[prost(int64, tag = "2")]
    pub user_id: i64,
    #[prost(enumeration = "ReactionAction", tag = "3")]
    pub action: i32,
    #[prost(string, tag = "4")]
    pub emoji: ::prost::alloc::string::String,
    #[prost(int64, tag = "5")]
    pub at: i64,
}
/// æ­£åœ¨è¾“å…¥
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Typing {
    #[prost(int64, tag = "1")]
    pub from_user_id: i64,
    #[prost(enumeration = "TypingState", tag = "3")]
    pub state: i32,
    #[prost(int64, tag = "4")]
    pub at: i64,
    #[prost(int64, repeated, tag = "6")]
    pub notify_user_ids: ::prost::alloc::vec::Vec<i64>,
    #[prost(oneof = "typing::Target", tags = "2, 5")]
    pub target: ::core::option::Option<typing::Target>,
}
/// Nested message and enum types in `Typing`.
pub mod typing {
    #[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Target {
        #[prost(int64, tag = "2")]
        ToUserId(i64),
        #[prost(int64, tag = "5")]
        GroupId(i64),
    }
}
/// ===============
/// åŠ å¯†è½½è·å°è£…ï¼ˆç«¯åˆ°ç«¯åŠ å¯†ï¼‰
/// ===============
/// è¯´æ˜ï¼šæœåŠ¡ç«¯åªé€ä¼ æœ¬ç»“æ„ä¸­çš„å¯†æ–‡ï¼Œä¸è§£å¯†
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EncryptedContent {
    /// åŠ å¯†æ–¹æ¡ˆæ ‡è¯†ï¼Œå¦‚ "x25519+chacha20poly1305"
    #[prost(string, tag = "1")]
    pub scheme: ::prost::alloc::string::String,
    /// å‘é€æ–¹çš„ä¼šè¯å…¬é’¥ï¼ˆå¦‚ X25519 å…¬é’¥ï¼‰
    #[prost(bytes = "vec", tag = "2")]
    pub sender_pub: ::prost::alloc::vec::Vec<u8>,
    /// ä¼šè¯/å¯†é’¥æ ‡è¯†ï¼ˆä¾¿äºæ¥æ”¶ç«¯å®šä½å¯†é’¥ææ–™ï¼‰
    #[prost(string, tag = "3")]
    pub key_id: ::prost::alloc::string::String,
    /// AEAD éšæœºæ•°/è®¡æ•°éšæœºé‡
    #[prost(bytes = "vec", tag = "4")]
    pub nonce: ::prost::alloc::vec::Vec<u8>,
    /// AEAD å¯†æ–‡ï¼ˆå«è®¤è¯æ ‡ç­¾ï¼‰ï¼›å¯†æ–‡å†…å®¹ä¸ºâ€œå•æ¡ MessageContent çš„ Protobuf ç¼–ç â€
    /// æ³¨æ„ï¼šä»…å¯¹ MessageContent åŠ å¯†ï¼Œé¡¶å±‚ Content çš„å…ƒæ•°æ®ï¼ˆsender/receiver/timestamp/scene/message_typeï¼‰ä¿æŒæ˜æ–‡
    #[prost(bytes = "vec", tag = "5")]
    pub ciphertext: ::prost::alloc::vec::Vec<u8>,
    /// é™„åŠ è®¤è¯æ•°æ®ï¼ˆA.A.D.ï¼Œå¯ä¸ºç©ºï¼‰
    /// å»ºè®®åŒ…å«ï¼šmessage_id|sender_id|receiver_id|scene|timestampï¼ˆæŒ‰ä¸€è‡´åºæ‹¼æ¥ï¼‰ï¼Œç”¨äºç«¯åˆ°ç«¯é˜²ç¯¡æ”¹
    #[prost(bytes = "vec", tag = "6")]
    pub aad: ::prost::alloc::vec::Vec<u8>,
    /// å‘é€æ–¹æœ¬åœ°å•è°ƒæ¶ˆæ¯åºå·ï¼ˆé˜²é‡æ”¾/ä¹±åºï¼‰
    #[prost(uint64, tag = "7")]
    pub msg_no: u64,
}
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ContentType {
    /// æœªçŸ¥
    Unknown = 0,
    /// æ–‡æœ¬
    Text = 1,
    /// å›¾ç‰‡
    Image = 2,
    /// éŸ³é¢‘
    Audio = 3,
    /// è§†é¢‘
    Video = 4,
    /// å¯Œæ–‡æœ¬
    Html = 5,
    /// ä½ç½®
    Location = 6,
    /// æ–‡ä»¶
    File = 7,
    /// è¡¨æƒ…
    Emoji = 8,
    /// å¼•ç”¨
    Quote = 9,
    /// éŸ³è§†é¢‘é€šè¯ä¿¡ä»¤
    AvCall = 10,
    /// VOIP é€šè¯è®°å½•
    Voip = 11,
    /// é€šçŸ¥
    Notification = 12,
    /// ç³»ç»Ÿæ¶ˆæ¯
    System = 13,
    /// æé†’
    Reminder = 14,
    /// å¥½å‹äº‹ä»¶
    FriendEvent = 15,
    /// æ¶ˆæ¯æ’¤å›
    Revoke = 17,
    /// æ¶ˆæ¯è½¬å‘
    Forward = 18,
    /// åç‰‡
    ContactCard = 19,
    /// æŠ•ç¥¨
    Vote = 20,
    /// çº¢åŒ…
    RedEnvelope = 21,
    /// åŠ å¯†æ¶ˆæ¯ï¼ˆä»… MessageContent åŠ å¯†ï¼›é¡¶å±‚å…ƒæ•°æ®ä¿æŒæ˜æ–‡ï¼‰
    Encrypted = 22,
    /// é€šç”¨ä¸šåŠ¡ç¡®è®¤/é€šçŸ¥ï¼ˆå¤„ç†ç»“æœå›æ‰§ï¼‰
    Ack = 23,
    /// è‡ªå®šä¹‰æ¶ˆæ¯
    Custom = 100,
}
impl ContentType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "UNKNOWN",
            Self::Text => "TEXT",
            Self::Image => "IMAGE",
            Self::Audio => "AUDIO",
            Self::Video => "VIDEO",
            Self::Html => "HTML",
            Self::Location => "LOCATION",
            Self::File => "FILE",
            Self::Emoji => "EMOJI",
            Self::Quote => "QUOTE",
            Self::AvCall => "AV_CALL",
            Self::Voip => "VOIP",
            Self::Notification => "NOTIFICATION",
            Self::System => "SYSTEM",
            Self::Reminder => "REMINDER",
            Self::FriendEvent => "FRIEND_EVENT",
            Self::Revoke => "REVOKE",
            Self::Forward => "FORWARD",
            Self::ContactCard => "CONTACT_CARD",
            Self::Vote => "VOTE",
            Self::RedEnvelope => "RED_ENVELOPE",
            Self::Encrypted => "ENCRYPTED",
            Self::Ack => "ACK",
            Self::Custom => "CUSTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN" => Some(Self::Unknown),
            "TEXT" => Some(Self::Text),
            "IMAGE" => Some(Self::Image),
            "AUDIO" => Some(Self::Audio),
            "VIDEO" => Some(Self::Video),
            "HTML" => Some(Self::Html),
            "LOCATION" => Some(Self::Location),
            "FILE" => Some(Self::File),
            "EMOJI" => Some(Self::Emoji),
            "QUOTE" => Some(Self::Quote),
            "AV_CALL" => Some(Self::AvCall),
            "VOIP" => Some(Self::Voip),
            "NOTIFICATION" => Some(Self::Notification),
            "SYSTEM" => Some(Self::System),
            "REMINDER" => Some(Self::Reminder),
            "FRIEND_EVENT" => Some(Self::FriendEvent),
            "REVOKE" => Some(Self::Revoke),
            "FORWARD" => Some(Self::Forward),
            "CONTACT_CARD" => Some(Self::ContactCard),
            "VOTE" => Some(Self::Vote),
            "RED_ENVELOPE" => Some(Self::RedEnvelope),
            "ENCRYPTED" => Some(Self::Encrypted),
            "ACK" => Some(Self::Ack),
            "CUSTOM" => Some(Self::Custom),
            _ => None,
        }
    }
}
/// ======================================
/// ğŸ˜„ Emoji ç±»å‹å®šä¹‰ï¼ˆæ ‡å‡† + è‡ªå®šä¹‰ï¼‰
/// ======================================
/// å®šä¹‰äº†ç³»ç»Ÿä¸­æ”¯æŒçš„ emoji ç±»å‹ï¼ŒåŒ…æ‹¬æ ‡å‡† emoji å’Œè‡ªå®šä¹‰è¡¨æƒ…
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EmojiType {
    EmojiUnknown = 0,
    /// å¾®ç¬‘è¡¨æƒ…
    Smile = 1,
    /// å’§å˜´ç¬‘è¡¨æƒ…
    Grin = 2,
    /// æµæ³ªè¡¨æƒ…
    Tears = 3,
    /// åèˆŒå¤´è¡¨æƒ…
    StuckOutTongue = 4,
    /// é¼“æŒè¡¨æƒ…
    Clap = 25,
    /// ä¾¿ä¾¿è¡¨æƒ…
    Poop = 28,
    /// çˆ±å¿ƒè¡¨æƒ…
    Heart = 21,
    /// ... å¯ç»§ç»­æ‰©å±•æ ‡å‡† Emoji
    /// è‡ªå®šä¹‰è¡¨æƒ…ï¼ˆé€šè¿‡å›¾ç‰‡ URL æŒ‡å®šï¼‰
    CustomEmoji = 1000,
}
impl EmojiType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::EmojiUnknown => "EMOJI_UNKNOWN",
            Self::Smile => "SMILE",
            Self::Grin => "GRIN",
            Self::Tears => "TEARS",
            Self::StuckOutTongue => "STUCK_OUT_TONGUE",
            Self::Clap => "CLAP",
            Self::Poop => "POOP",
            Self::Heart => "HEART",
            Self::CustomEmoji => "CUSTOM_EMOJI",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EMOJI_UNKNOWN" => Some(Self::EmojiUnknown),
            "SMILE" => Some(Self::Smile),
            "GRIN" => Some(Self::Grin),
            "TEARS" => Some(Self::Tears),
            "STUCK_OUT_TONGUE" => Some(Self::StuckOutTongue),
            "CLAP" => Some(Self::Clap),
            "POOP" => Some(Self::Poop),
            "HEART" => Some(Self::Heart),
            "CUSTOM_EMOJI" => Some(Self::CustomEmoji),
            _ => None,
        }
    }
}
/// é€šè¯åª’ä½“ç±»å‹
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CallMediaType {
    /// è¯­éŸ³
    CallAudio = 0,
    /// è§†é¢‘
    CallVideo = 1,
}
impl CallMediaType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CallAudio => "CALL_AUDIO",
            Self::CallVideo => "CALL_VIDEO",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CALL_AUDIO" => Some(Self::CallAudio),
            "CALL_VIDEO" => Some(Self::CallVideo),
            _ => None,
        }
    }
}
/// é€šè¯ç»“æŸåŸå› 
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CallEndReason {
    /// æœªæŒ‡å®š
    CerUnspecified = 0,
    /// ä¸»åŠ¨å–æ¶ˆ
    CerCancelled = 1,
    /// å¯¹æ–¹æ‹’ç»
    CerRejected = 2,
    /// å¯¹æ–¹å¿™
    CerBusy = 3,
    /// è¶…æ—¶æœªåº”ç­”
    CerTimeout = 4,
    /// æ­£å¸¸æŒ‚æ–­
    CerHangup = 5,
    /// å¤±è´¥/å¼‚å¸¸
    CerFailed = 6,
}
impl CallEndReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CerUnspecified => "CER_UNSPECIFIED",
            Self::CerCancelled => "CER_CANCELLED",
            Self::CerRejected => "CER_REJECTED",
            Self::CerBusy => "CER_BUSY",
            Self::CerTimeout => "CER_TIMEOUT",
            Self::CerHangup => "CER_HANGUP",
            Self::CerFailed => "CER_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CER_UNSPECIFIED" => Some(Self::CerUnspecified),
            "CER_CANCELLED" => Some(Self::CerCancelled),
            "CER_REJECTED" => Some(Self::CerRejected),
            "CER_BUSY" => Some(Self::CerBusy),
            "CER_TIMEOUT" => Some(Self::CerTimeout),
            "CER_HANGUP" => Some(Self::CerHangup),
            "CER_FAILED" => Some(Self::CerFailed),
            _ => None,
        }
    }
}
/// é€šè¯å†…ä¿®æ”¹ç±»å‹
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CallModifyType {
    /// é™éŸ³/å–æ¶ˆé™éŸ³
    CmtMute = 0,
    /// å¼€/å…³æ‘„åƒå¤´
    CmtCamera = 1,
    /// ä¿æŒ/æ¢å¤é€šè¯
    CmtHold = 2,
    /// åˆ‡æ¢å‰åæ‘„
    CmtSwitchCamera = 3,
}
impl CallModifyType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CmtMute => "CMT_MUTE",
            Self::CmtCamera => "CMT_CAMERA",
            Self::CmtHold => "CMT_HOLD",
            Self::CmtSwitchCamera => "CMT_SWITCH_CAMERA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CMT_MUTE" => Some(Self::CmtMute),
            "CMT_CAMERA" => Some(Self::CmtCamera),
            "CMT_HOLD" => Some(Self::CmtHold),
            "CMT_SWITCH_CAMERA" => Some(Self::CmtSwitchCamera),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChatScene {
    /// é»˜è®¤æœªçŸ¥åœºæ™¯ï¼ˆé˜²å¾¡å€¼ï¼‰
    ChatUnknown = 0,
    /// å•äººä¼šè¯ï¼šç”¨æˆ·ä¸ç”¨æˆ·ä¹‹é—´çš„ç§èŠ
    Single = 1,
    /// ç¾¤èŠä¼šè¯ï¼šç¾¤ç»„å†…çš„å¤šäººèŠå¤©
    Group = 2,
}
impl ChatScene {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ChatUnknown => "CHAT_UNKNOWN",
            Self::Single => "SINGLE",
            Self::Group => "GROUP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHAT_UNKNOWN" => Some(Self::ChatUnknown),
            "SINGLE" => Some(Self::Single),
            "GROUP" => Some(Self::Group),
            _ => None,
        }
    }
}
/// Reaction æ“ä½œ
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReactionAction {
    RaAdd = 0,
    RaRemove = 1,
}
impl ReactionAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::RaAdd => "RA_ADD",
            Self::RaRemove => "RA_REMOVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RA_ADD" => Some(Self::RaAdd),
            "RA_REMOVE" => Some(Self::RaRemove),
            _ => None,
        }
    }
}
/// æ­£åœ¨è¾“å…¥çŠ¶æ€
#[derive(serde::Serialize, serde::Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TypingState {
    TypingNone = 0,
    TypingText = 1,
    TypingVoice = 2,
    TypingUpload = 3,
}
impl TypingState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TypingNone => "TYPING_NONE",
            Self::TypingText => "TYPING_TEXT",
            Self::TypingVoice => "TYPING_VOICE",
            Self::TypingUpload => "TYPING_UPLOAD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TYPING_NONE" => Some(Self::TypingNone),
            "TYPING_TEXT" => Some(Self::TypingText),
            "TYPING_VOICE" => Some(Self::TypingVoice),
            "TYPING_UPLOAD" => Some(Self::TypingUpload),
            _ => None,
        }
    }
}
