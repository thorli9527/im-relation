syntax = "proto3";
import "message.proto";

package socket;

// 客户端握手请求：连接建立后首帧（现在置于 ClientMsg.auth）
message AuthMsg {
  // 用户唯一 ID（由服务端体系分配）
  int64 uid = 1;
  // 设备类型（枚举，复用 message.DeviceType）
  .message.DeviceType device_type = 2;
  // 设备标识（业务自定义，如设备号、推送 token 等）
  string device_id = 3;
  // 鉴权令牌（JWT/opaque），用于绑定 user_id 校验
  string token = 4;
  // 客户端时间戳（毫秒），用于时钟漂移/重放保护
  int64 ts_ms = 5;
  // 随机数，结合签名防重放
  bytes nonce = 6;
  // 对关键字段的签名/HMAC（例如 HMAC(key, user_id|device_id|ts|nonce|token) ）
  bytes signature = 7;
  // 是否尝试恢复会话（断线重连）
  bool resume = 8;
  // 客户端已确认的最后一条消息 ID（用于快速补发）
  int64 last_ack_id = 9;
  // 能力协商：是否支持端到端加密（仅占位，不影响现有流程）
  bool supports_encryption = 10;
  // 支持的加密方案（如 "x25519+chacha20poly1305"）
  repeated string encryption_schemes = 11;
}

// 客户端上行消息（含 ACK）
message ClientMsg {
  // 若存在，表示对服务端某条 id 的确认
  optional int64 ack = 1;
  // 鉴权载荷（首帧必须携带）
  optional AuthMsg auth = 2;
  // 心跳包标志位（仅用于保活，不携带业务 payload）
  optional bool heartbeat = 4;
  // 业务负载（二进制，建议为 message.Content）
  bytes payload = 3;
  // 客户端上行幂等ID（用于去重/重试对账），不参与 ACK 语义
  optional int64 client_id = 5;
}

// 服务端下行消息（投递给客户端）
message ServerMsg {
  // 消息唯一 ID（用于客户端 ACK 对齐）
  int64 id = 1;
  // 鉴权结果（鉴权成功时返回，替代系统业务通知）
  optional AuthMsg auth = 2;
  // 二进制负载（建议为具体业务的 Protobuf，例如 message.Content）
  bytes payload = 3;
  // 业务时间戳（毫秒）
  int64 ts_ms = 4;
}
